<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Plus Ultra</title>
  
  <subtitle>仰望星空，脚踏实地</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-16T16:44:08.768Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lollipop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sublime Text 3 快捷键</title>
    <link href="http://yoursite.com/2018/09/16/Sublime%20Text%203%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2018/09/16/Sublime Text 3 快捷键/</id>
    <published>2018-09-16T12:12:34.000Z</published>
    <updated>2018-09-16T16:44:08.768Z</updated>
    
    <content type="html"><![CDATA[<p>Ctrl+Shift+P：打开命令面板<br>Ctrl+P：搜索项目中的文件<br>Ctrl+G：跳转到第几行<br>Ctrl+W：关闭当前打开文件<br>Ctrl+Shift+W：关闭所有打开文件<br>Ctrl+Shift+V：粘贴并格式化<br>Ctrl+D：选择单词，重复可增加选择下一个相同的单词<br>Ctrl+L：选择行，重复可依次增加选择下一行<br>Ctrl+Shift+L：选择多行<br>Ctrl+Shift+Enter：在当前行前插入新行<br>Ctrl+X：删除当前行<br>Ctrl+M：跳转到对应括号<br>Ctrl+U：软撤销，撤销光标位置<br>Ctrl+J：选择标签内容<br>Ctrl+F：查找内容<br>Ctrl+Shift+F：查找并替换<br>Ctrl+H：替换<br>Ctrl+R：前往 method<br>Ctrl+N：新建窗口<br>Ctrl+K+B：开关侧栏<br>Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身<br>Ctrl+F2：设置/删除标记<br>Ctrl+/：注释当前行<br>Ctrl+Shift+/：当前位置插入注释<br>Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的<br>Ctrl+Shift+A：选择当前标签前后，修改标签用的<br>F11：全屏<br>Shift+F11：全屏免打扰模式，只编辑当前文件<br>Alt+F3：选择所有相同的词<br>Alt+.：闭合标签<br>Alt+Shift+数字：分屏显示<br>Alt+数字：切换打开第N个文件<br>Shift+右键拖动：光标多不，用来更改或插入列内容<br>鼠标的前进后退键可切换Tab文件<br>按Ctrl，依次点击或选取，可需要编辑的多个位置<br>按Ctrl+Shift+上下键，可替换行</p><h2 id="选择类"><a href="#选择类" class="headerlink" title="选择类"></a>选择类</h2><p>Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。<br>Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。<br>Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。<br>Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。<br>Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。<br>Ctrl+M 光标移动至括号内结束或开始的位置。<br>Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。<br>Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。<br>Ctrl+K+0 展开所有折叠代码。<br>Ctrl+← 向左单位性地移动光标，快速移动光标。<br>Ctrl+→ 向右单位性地移动光标，快速移动光标。<br>shift+↑ 向上选中多行。<br>shift+↓ 向下选中多行。<br>Shift+← 向左选中文本。<br>Shift+→ 向右选中文本。<br>Ctrl+Shift+← 向左单位性地选中文本。<br>Ctrl+Shift+→ 向右单位性地选中文本。<br>Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。<br>Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。<br>Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。<br>Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。</p><h2 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h2><p>Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。<br>Ctrl+Shift+D 复制光标所在整行，插入到下一行。<br>Tab 向右缩进。<br>Shift+Tab 向左缩进。<br>Ctrl+K+K 从光标处开始删除代码至行尾。<br>Ctrl+Shift+K 删除整行。<br>Ctrl+/ 注释单行。<br>Ctrl+Shift+/ 注释多行。<br>Ctrl+K+U 转换大写。<br>Ctrl+K+L 转换小写。<br>Ctrl+Z 撤销。<br>Ctrl+Y 恢复撤销。<br>Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。<br>Ctrl+F2 设置书签<br>Ctrl+T 左右字母互换。<br>F6 单词检测拼写</p><h2 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h2><p>Ctrl+F 打开底部搜索框，查找关键字。<br>Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。<br>Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。<br>Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。<br>Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。<br>Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。<br>Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。<br>Esc 退出光标多行选择，退出搜索框，命令框等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ctrl+Shift+P：打开命令面板&lt;br&gt;Ctrl+P：搜索项目中的文件&lt;br&gt;Ctrl+G：跳转到第几行&lt;br&gt;Ctrl+W：关闭当前打开文件&lt;br&gt;Ctrl+Shift+W：关闭所有打开文件&lt;br&gt;Ctrl+Shift+V：粘贴并格式化&lt;br&gt;Ctrl+D：选择单词
      
    
    </summary>
    
      <category term="Practice" scheme="http://yoursite.com/categories/Practice/"/>
    
    
      <category term="Program" scheme="http://yoursite.com/tags/Program/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2018/09/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/15/正则表达式/</id>
    <published>2018-09-15T15:12:29.000Z</published>
    <updated>2018-09-15T16:56:34.928Z</updated>
    
    <content type="html"><![CDATA[<p>一个正则表达式通常被称为一个模式（pattern）</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>竖线|代表选择（即或集），具有最低优先级。例如gray|grey可以匹配grey或gray</p><h3 id="数量限定-、-和"><a href="#数量限定-、-和" class="headerlink" title="数量限定+、?和*"></a>数量限定+、?和*</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加号+代表前面的字符必须至少出现一次。（1次或多次）。例如，goo+gle可以匹配google、gooogle、goooogle等;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问号?代表前面的字符最多只可以出现一次。（0次或1次）。例如，colou?r可以匹配color或者colour;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">星号*代表前面的字符可以不出现，也可以出现一次或者多次。（0次、1次或多次）。例如，0*42可以匹配42、042、0042、00042等。</span><br></pre></td></tr></table></figure><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p>圆括号()可以用来定义操作符的范围和优先度<br>例如，gr(a|e)y等价于gray|grey<br>要做更精确地匹配，可以用[]表示范围</p><p><strong>[0-9a-zA-Z_]</strong>可以匹配一个数字、字母或者下划线；<br><strong>[0-9a-zA-Z_]+</strong>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如’a100’，’0_Z’，’Py3000’等等；<br><strong>[a-zA-Z_][0-9a-zA-Z_]*</strong>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；<br><strong>[a-zA-Z_][0-9a-zA-Z_]{0, 19}</strong>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</p><h3 id="表达式全集"><a href="#表达式全集" class="headerlink" title="表达式全集"></a>表达式全集</h3><p>适用于Perl或者Python编程语言（grep或者egrep的正则表达式文法是PCRE的子集）：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">\</th><th>“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”</th></tr></thead><tbody><tr><td style="text-align:center">^</td><td style="text-align:center">匹配输入字符串的开始位置</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配输入字符串的结束位置</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">匹配除“\r”“\n”之外的任何单个字符。要匹配包括“\r”“\n”在内的任何字符，请使用像“(.</td><td>\r</td><td>\n)”的模式。</td></tr><tr><td style="text-align:center">(?:pattern)</td><td style="text-align:center">匹配pattern但不获取匹配的子字符串（shy groups），也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。这在使用或字符“(</td><td>)”来组合一个模式的各个部分是很有用。例如“industr(?:y</td><td>ies)”就是一个比“industry</td><td>industries”更简略的表达式。</td></tr><tr><td style="text-align:center">[xyz]</td><td style="text-align:center">字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td></tr><tr><td style="text-align:center">[^xyz]</td><td style="text-align:center">排除型字符集合（negated character classes）。</td></tr><tr><td style="text-align:center">[a-z]</td><td style="text-align:center">字符范围。匹配指定范围内的任意字符。</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配一个数字字符。</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配一个非数字字符。</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">匹配一个换页符。</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:center">匹配一个换行符。</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">匹配一个回车符</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任何空白字符，</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配任何非空白字符</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">匹配一个制表符</td></tr><tr><td style="text-align:center">\v</td><td style="text-align:center">匹配一个垂直制表符。</td></tr></tbody></table><p><code>https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</code><br>正则匹配URL：[a-zA-z]+://[^\s]*</p><p><code>正则测试网站：http://tool.oschina.net/regex#</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个正则表达式通常被称为一个模式（pattern）&lt;/p&gt;
&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h2&gt;&lt;h3 id=&quot;选择&quot;&gt;&lt;a href=&quot;#选择&quot; class=
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP读书笔记</title>
    <link href="http://yoursite.com/2018/09/15/%E5%9B%BE%E8%A7%A3HTTP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/09/15/图解HTTP读书笔记/</id>
    <published>2018-09-15T15:12:29.000Z</published>
    <updated>2018-09-16T16:44:12.483Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h2><blockquote><p>HTTP 是一个属于应用层的面向对象的协议，HTTP 协议一共有五大特点：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 特性解读</span><br><span class="line"> `客户/服务器模式, 请求/响应模式`</span><br><span class="line"> `简单快速`</span><br><span class="line"> 客户向服务器请求服务时，只需传送请求方法和路径。</span><br><span class="line"> </span><br><span class="line"> `灵活`</span><br><span class="line"> HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</span><br><span class="line"> </span><br><span class="line"> `无连接`  TCP连接是否断开，HTTP/1.0之后的版本默认为持久连接</span><br><span class="line">限制每次连接只处理一个请求。请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。容量小时，可节省传输时间。容量大时，则会增加通信量的开销，使得传输效率降低。</span><br><span class="line"></span><br><span class="line"> `持久连接-Keep alive` </span><br><span class="line"> 只要任意一端没有明确提出断开连接，则保持TCP连接状态。在建立连接后可进行多次请求与响应</span><br><span class="line"> `管线化 pipelining`</span><br><span class="line"> keep-alive使得pipelining成为可能,可同时并行发送多个请求</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> `无状态 stateless`</span><br><span class="line"> HTTP是一种不保存状态，即无状态协议，不对请求和响应之间的通信状态进行保存。HHTP协议的每个请求都是独立的，Keep-Alive 没能改变这个结果。</span><br><span class="line"> |优点|缺点</span><br><span class="line">:-:|:-:|:-:</span><br><span class="line"> |更快地处理更多事务，确保协议可伸缩性|没法保存客户机信息,阻碍了交互式应用程序的实现</span><br><span class="line"> 减少服务器CPU及内存资源消耗|每次请求会传输大量重复的内容信息。</span><br><span class="line"> &gt;由此有状态管理: `Cookie` `session`</span><br><span class="line"> `使用cookie状态管理`</span><br><span class="line"> cookie机制采用的是在客户端保持状态的方案.</span><br><span class="line"> `使用 session 状态管理`</span><br><span class="line"> session机制采用的是在服务器端保持状态的方案，典型的场景比如购物车。Tomcat中将session叫jsession</span><br><span class="line"></span><br><span class="line"> &gt;&gt; [`JSESSIONID和sessionid的区别`](https://blog.csdn.net/czh500/article/details/80216726)</span><br><span class="line"></span><br><span class="line">### Cookie vs Session</span><br><span class="line"> `Cookie`</span><br></pre></td></tr></table></figure></p></blockquote><pre><code>包含用户信息和计算机浏览器信息,根据生命期不同分成两种：会话cookie和持久cookie；会话cookie保存在内存里，浏览器退出即消失。持久cookie为硬盘cookie，设置了过期时间，在过期时间内，存储在硬盘上的cookie可以在不同的浏览器进程间共享。故根据硬件分类，又分为内存cookie和硬盘cookie，主要用于解决HTTP无状态、无法实现交互式web应用程序的问题，服务器读取cookie，维护用户和服务器会话的状态。Cookie具有不可跨域名性。主要用途：会话状态管理、个性化设置、浏览器行为跟踪跨站点脚本攻击，cookie盗贼（搜集用户cookie）和cookie投毒（修改传入服务器的cookie）</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`session`</span><br></pre></td></tr></table></figure><pre><code>第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器。Session就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户，Session是以Cookie或URL重写为基础的，默认使用Cookie来实现，系统会创造一个名为JSESSIONID的输出Cookie，我们叫Session Cookie,以区别Persistent cookies,也就是我们通常所说的cookie。注意session cookie是存储于浏览器内存中的，并不是写到硬盘上的，即JSESSIONID，通常是看不到JSESSIONID的。</code></pre><p>   虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。<br>   只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。<br>    禁用cookie后，利用URL重写重写技术，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">`cookie &amp; session`</span><br><span class="line">```Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</span><br><span class="line">Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。cookie携带session id后，到服务端session做验证。</span><br><span class="line">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><br><span class="line">2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</span><br><span class="line">3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</span><br><span class="line">4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><br><span class="line">5、所以个人建议：</span><br><span class="line">   将登陆信息等重要信息存放为SESSION</span><br><span class="line">   其他信息如果需要保留，可以放在COOKIE中</span><br></pre></td></tr></table></figure></p><h3 id="防session-id窃取方案"><a href="#防session-id窃取方案" class="headerlink" title="防session id窃取方案"></a>防session id窃取方案</h3><p>窃取途径：XSS（恶意代码）、CSRF（钓鱼网站），攻击防御<br>防窃取方案：cookie不存放敏感信息和用户不应知道的信息，只存放session id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置HttpOnly属性防止XSS攻击。在PHP中，可以通过修改php.ini中的“session.cookie_httponly = 1 ”开启全局Cookie的HttpOnly属性。也可以使用“setcookie”函数来启用。</span><br><span class="line">客户端发生变化时，要求用户重新登录。例如使用User-Agent、IP地址、MAC地址等检测请求的一致性,并且加入Token进行检验。</span><br><span class="line">更改SessionID名称。例如PHP中SessionID的默认名称是PHPSESSID，此变量会保存在Cookie中，如果攻击者不分析站点，就不能猜到SessionID的名称，阻挡部分攻击。加大SessionID的安全长度，加大暴力猜解难度。</span><br><span class="line">为每一次请求生成新的SessionID，特别是登陆前后的 SessionID需要有所不相同，只接受服务器生成的SessionID。</span><br><span class="line">设置会话超时属性，设定阈值强制会话过期。</span><br></pre></td></tr></table></figure></p><p>参考链接：<br><a href="https://blog.csdn.net/fangaoxin/article/details/6952954" target="_blank" rel="noopener">Cookie/Session机制详解</a></p><h2 id="HTTP1-0-1-1-2-0-区别"><a href="#HTTP1-0-1-1-2-0-区别" class="headerlink" title="HTTP1.0/1.1/2.0 区别"></a>HTTP1.0/1.1/2.0 区别</h2><p><code>HTTP/1.0</code>：多媒体处理，HTTP请求头支持多种请求；连接无法复用，请求分离，线头阻塞（请求无法响应，后面的请求被阻塞）。<br><code>HTTP/1.1</code>：可扩展性、缓存处理、带宽优化、持久连接、Host头、错误通知、消息传递、内容协商等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 默认持久连接（Connection: keep-alive）和流⽔水线传输（即不用等上一个响应再发下⼀个），关闭：Connection: closed；</span><br><span class="line">2. 增加了请求头和响应头来扩充功能：</span><br><span class="line">a. 支持Host请求；</span><br><span class="line">b. Connection；</span><br><span class="line">c. 支持断点续传；</span><br><span class="line">d. 身份认证；</span><br><span class="line">e. 状态管理；</span><br><span class="line">f. Cache缓存处理。</span><br><span class="line">3. 状态码100 Continue， POST时大于1024，先询问是否接收（状态码较多，部分由其它RFC定义）</span><br><span class="line">4. Host 域：一台物理理主机对应多个虚拟主机-&gt;共享⼀一个ip</span><br><span class="line">5. 可分块传输数据：Transfer-Encoding: chunked否则对于动态⽣生成的响应，要把响应整个缓存才知道长度，才能填写Content-Length</span><br></pre></td></tr></table></figure></p><p><code>HTTP/2.0</code>：把解决性能问题的方案内置在了传输层，添加二进制帧分层，通过多路复用来减少延迟，通过压缩 HTTP首部降低开销，同时增加请求优先级和服务器端推送的功能。<br><a href="https://developers.google.cn/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP/2 简介</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.支持多路复用</span><br><span class="line">    每个来源一个连接，多路复用允许同时通过单一的 HTTP 2.0 连接发起多重的请求-响应消息，即所有HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可，所有数据流共用同一个连接，减少了因http链接多而引起的网络拥塞（在 HTTP1.1 协议中，同一时间，浏览器会针对同一域名下的请求有一定数量限制），解决了慢启动针对突发性和短时性的http链接低效的问题。</span><br><span class="line">    流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力。</span><br><span class="line">2.将通信的基本单位缩小为帧</span><br><span class="line">    请求和响应复用：客户端和服务器可以将 HTTP </span><br><span class="line">    消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。</span><br><span class="line">    HTTP/2 中的新二进制分帧层解决了 HTTP/1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。结果，应用速度更快、开发更简单、部署成本更低。</span><br><span class="line">3.首部压缩</span><br><span class="line">    HTTP/2 支持DEFLATE和HPACK 算法的压缩，经过专门设计，可以解决发现的安全问题、实现起来也更高效和简单，可以对 HTTP 标头元数据进行良好压缩。（动态索引表）</span><br><span class="line">4.服务端推送</span><br><span class="line">    客户端请求之前发送数据的机制，在 HTTP 2.0 中，服务器可以对客户端的一个请求发送多个响应，可推送额外的信息。</span><br><span class="line">5.请求优先级</span><br><span class="line">    HTTP 2.0 使用一个31比特的优先值,0表示最高优先级, 2(31)-1表示最低优先级，服务器端就可以根据优先级，控制资源分配，优先处理和返回最高优先级的请求帧给客户端。</span><br></pre></td></tr></table></figure></p><p><code>HTTP2.0与WebSocket</code></p><blockquote><p>HTTP 2.0服务器推送不是诸如Server-Sent Events (SSE)或WebSocket的技术替代品。通过HTTP 2.0服务器推送传递过来的资源由浏览器来处理，但却不能上升到程序代码的层面 - 因为没有JavaScript API来获取这些事件的通知。不过，解决这个难题的方法却很简单，因为我们可以把一个SSE通道和服务器推送结合起来，使两者都达到最佳效果。通过HTTP 2.0，服务器有机会变得非常非常智能，包括如何优化传送一些具体的资源，更重要的是，也包括优化对整个应用的传送。类似的，浏览器可能增加额外的API和能力来使这个过程更加高效。<br>在HTTP/2中，在场景后面使用服务器推送来提高客户端从浏览器加载资源的能力。作为一个开发人员，你在开发过程中并不真正关心它。但是，使用WebSocket，开发人员可以使用API，该API能够使用唯一的全双工连接来使用和推送消息。</p></blockquote><p>1 补充关系 二者侧重点不同。SPDY更侧重给Web页面的加载提速，而websocket更强调为web应用提供一种双向的通信机制以及API<br>2 竞争关系，二者解决的问题有交集，比如在服务器上推送上SPDY和Websocket都提供了方案<br>3 承载关系，SPDY若标准化早于websocket，则websocket完全可以侧重于API，利用SPDY的帧机制和多路复用机制实现该API<br>4 融合关系，如微软在HTTP Speed+Mobility中所做</p><h2 id="HTTP实现"><a href="#HTTP实现" class="headerlink" title="HTTP实现"></a>HTTP实现</h2><h3 id="HTTP在TCP-IP的通信传输流"><a href="#HTTP在TCP-IP的通信传输流" class="headerlink" title="HTTP在TCP/IP的通信传输流"></a>HTTP在TCP/IP的通信传输流</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#每通过一层都进行一次封装</span><br><span class="line"> 应用层 HTTP客户端 HTTP服务器   #HTTP报文  HTTP数据</span><br><span class="line">        ↓          ↑            </span><br><span class="line"> 传输层 TCP        TCP          #TCP报文段 TCP首部</span><br><span class="line">        ↓          ↑</span><br><span class="line"> 网络层 IP         IP           #IP数据包  IP首部</span><br><span class="line">        ↓          ↑</span><br><span class="line"> 链路层 网络  →    网络          #网络架构 以太网首部</span><br></pre></td></tr></table></figure><h3 id="各协议与HTTP协议的关系（TCP-IP-DNS）"><a href="#各协议与HTTP协议的关系（TCP-IP-DNS）" class="headerlink" title="各协议与HTTP协议的关系（TCP/IP DNS）"></a>各协议与HTTP协议的关系（TCP/IP DNS）</h3><blockquote><p>输入域名(url)–&gt;DNS映射为IP–&gt;TCP三次握手–&gt;HTTP请求–&gt;HTTP响应–&gt;(浏览器跟踪重定向地址)–&gt;服务器处理请求–&gt;服务器返回一个html响应–&gt;(视情况决定释放TCP连接)–&gt;客户端解析HTML–&gt;获取嵌入在HTML中的对象重新发起http请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 输入域名</span><br><span class="line">op1=&gt;operation: DNS映射为IP</span><br><span class="line">op2=&gt;operation: TCP三次握手</span><br><span class="line">op3=&gt;operation: HTTP请求</span><br><span class="line">cond=&gt;condition: url是否正确否则重定向</span><br><span class="line">op5=&gt;operation: 服务器处理请求</span><br><span class="line">op4=&gt;operation: 服务器返回html响应</span><br><span class="line">e=&gt;end: 客户端浏览器解析响应报文</span><br><span class="line"></span><br><span class="line">st(right)-&gt;op1</span><br><span class="line">op1(right)-&gt;op2</span><br><span class="line">op2-&gt;op3</span><br><span class="line">op3-&gt;cond</span><br><span class="line">cond-&gt;op5</span><br><span class="line">cond(no)-&gt;op3</span><br><span class="line">cond(yes)-&gt;op5</span><br><span class="line">op5(right)-&gt;op4</span><br><span class="line">op4(right)-&gt;e</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="HTTP重定向和转发"><a href="#HTTP重定向和转发" class="headerlink" title="HTTP重定向和转发"></a>HTTP重定向和转发</h3><p>1.<code>实际发生位置不同，地址栏不同</code></p><ul><li><strong>重定向是由浏览器进行跳转的</strong>，进行重定向跳转的时候，浏览器的地址会发生变化的。实现重定向的原理是由response的状态码和Location头组合而实现的。这是由浏览器进行的页面跳转<strong>实现重定向会发出两个http请求</strong>，**request域对象是无效的，因为它不是同一个request对象</li><li><strong>转发是由服务器进行跳转的</strong>，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问Servlet111的时候，即使跳转到了Servlet222的页面，浏览器的地址还是Servlet111的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，<strong>实现转发只是一次的http请求</strong>，一次转发中request和response对象都是同一个。这也解释了，为什么可以使用request作为域对象进行Servlet之间的通讯。</li><li><strong>转发是发生在服务器的</strong></li><li><strong>重定向是发生在浏览器的</strong></li></ul><p>2.<code>用法不同</code></p><ul><li>重定向时”/“代表的是webapps目录</li><li>转发时”/“代表的是本应用程序的根目录</li><li>资源地址书写：给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上</li><li>request.getRequestDispatcher(“/资源名 URI”).forward(request,response)</li><li>response.send(“/web应用/资源名 URI”);</li></ul><p>3.<strong><code>能够去往的URL的范围不一样</code></strong></p><ul><li>转发是服务器跳转只能去往当前web应用的资源</li><li>重定向是服务器跳转，可以去往任何的资源</li></ul><p>4.<code>传递数据的类型不同</code></p><ul><li>转发的request对象可以传递各种类型的数据，包括对象</li><li>重定向只能传递字符串</li></ul><p>5.<strong><code>跳转的时间不同</code></strong></p><ul><li>转发时：执行到跳转语句时就会立刻跳转</li><li>重定向：整个页面执行完之后才执行跳转</li></ul><h3 id="HTTP请求-响应的步骤"><a href="#HTTP请求-响应的步骤" class="headerlink" title="HTTP请求/响应的步骤"></a>HTTP请求/响应的步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 客户端连接到web服务器</span><br><span class="line">op1=&gt;operation: 客户端发送HTTP请求</span><br><span class="line">op2=&gt;operation: 服务器端解析请求并返回HTTP响应</span><br><span class="line">op3=&gt;operation: 释放TCP连接</span><br><span class="line">e=&gt;end: 客户端浏览器解析响应报文</span><br><span class="line"></span><br><span class="line">st-&gt;op1</span><br><span class="line">op1-&gt;op2</span><br><span class="line">op2-&gt;op3</span><br><span class="line">op3-&gt;e</span><br></pre></td></tr></table></figure><h3 id="浏览器解析和渲染-边解析边渲染"><a href="#浏览器解析和渲染-边解析边渲染" class="headerlink" title="浏览器解析和渲染(边解析边渲染)"></a>浏览器解析和渲染(边解析边渲染)</h3><p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">从输入URL到页面加载发生了什么</a><br>HTML文件构建DOM树–&gt;CSS文件构建CSSOM树–&gt;构建渲染树和布局–&gt;JS代码加载–&gt;页面绘制和渲染<br><code>js代码渲染完成后html才能进行html渲染</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st1=&gt;start: </span><br><span class="line">op1=&gt;operation: HTML文件构建DOM树</span><br><span class="line">op2=&gt;operation: CSS构建渲染树</span><br><span class="line">op3=&gt;operation: 布局渲染树</span><br><span class="line">e=&gt;end: 页面绘制和渲染</span><br><span class="line"></span><br><span class="line">st1-&gt;op1</span><br><span class="line">op1-&gt;op2</span><br><span class="line">op2-&gt;op3</span><br><span class="line">op3-&gt;e</span><br></pre></td></tr></table></figure><h2 id="HTTP优化"><a href="#HTTP优化" class="headerlink" title="HTTP优化"></a>HTTP优化</h2><p>负载均衡技术、TCP连接复用（多个客户端的HTTP请求复用到一个服务器端TCP连接上）、HTTP复用（管道pipelining）、内容缓存、TCP缓冲（解决后端服务器网速与客户的前端网络速度不匹配而造成的服务器资源浪费的问题）、HTTP压缩（对客户端的响应请求进行压缩处理：gzip、compress、deflate、identity）、SSL加速。</p><p><a href="https://www.cnblogs.com/kevingrace/p/6137975.html" target="_blank" rel="noopener">Http应用优化和加速说明-负载均衡</a><br><a href="https://blog.csdn.net/tennysonsky/article/details/45062079" target="_blank" rel="noopener">浅谈 C/S 和 B/S 架构</a></p><h2 id="HTTP报文信息"><a href="#HTTP报文信息" class="headerlink" title="HTTP报文信息"></a>HTTP报文信息</h2><h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p>报文首部+（CR+CF）+报文主体<br><code>请求报文</code><br>请求行  首部字段 其他（如cookie等）<br><code>响应报文</code><br>状态行  首部字段 其他（如cookie等）</p><h3 id="GET-vs-POST"><a href="#GET-vs-POST" class="headerlink" title="GET vs POST"></a>GET vs POST</h3><p>GET - 请求来自指定资源的数据<br>POST - 将要处理的数据提交给指定的资源<br>|GET|POST<br>:-:|:-:|:-:<br>GET请求可以被缓存|POST请求永远不会被缓存<br>GET请求保留在浏览器历史记录中|POST不保留在浏览器历史记录中<br>GET请求可以加书签|POST请求不能加书签<br>在处理敏感数据时绝不能使用GET请求|POST请求对数据长度没有限制<br>GET请求有长度限制|<br>GET请求只能用于检索数据|</p><h3 id="常用的HTTP方法"><a href="#常用的HTTP方法" class="headerlink" title="常用的HTTP方法"></a>常用的HTTP方法</h3><p>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。<br>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。<br>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。<br>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。<br>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。<br>MOVE：请求服务器将指定页面移至另一台服务器。<br>OPTIONS：查询相应URI支持的HTTP方法。</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1xx：指示信息--表示请求已接收，继续处理</span><br><span class="line">2xx：成功--表示请求已被成功接收、理解、接受</span><br><span class="line">    200：请求被正常处理</span><br><span class="line">    204：请求被受理但没有资源可以返回</span><br><span class="line">    206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</span><br><span class="line">3xx：重定向--要完成请求必须进行更进一步的操作</span><br><span class="line">    301：永久性重定向</span><br><span class="line">    302：临时重定向</span><br><span class="line">    303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</span><br><span class="line">    304：发送附带条件的请求时，条件不满足时返回，与重定向无关</span><br><span class="line">    307：临时重定向，与302类似，只是强制要求使用POST方法</span><br><span class="line">4xx：客户端错误--请求有语法错误或请求无法实现</span><br><span class="line">    400：请求报文语法有误，服务器无法识别</span><br><span class="line">    401：请求需要认证</span><br><span class="line">    403：请求的对应资源禁止被访问</span><br><span class="line">    404：服务器无法找到对应资源</span><br><span class="line">5xx：服务器端错误--服务器未能实现合法的请求</span><br><span class="line">    500：服务器内部错误</span><br><span class="line">    502：错误网关，作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。，</span><br><span class="line">    503：临时的服务器维护或者过载，服务器当前无法处理请求</span><br></pre></td></tr></table></figure><h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><p><code>a、通用首部字段</code>（请求报文与响应报文都会使用的首部字段）<br>Date：创建报文时间<br>Connection：连接的管理<br>Cache-Control：缓存的控制<br>Transfer-Encoding：报文主体的传输编码方式</p><p><code>b、请求首部字段</code>（请求报文会使用的首部字段）<br>Host：请求资源所在服务器<br>Accept：可处理的媒体类型<br>Accept-Charset：可接收的字符集<br>Accept-Encoding：可接受的内容编码<br>Accept-Language：可接受的自然语言</p><p><code>c、响应首部字段</code>（响应报文会使用的首部字段）<br>Accept-Ranges：可接受的字节范围<br>Location：令客户端重新定向到的URI<br>Server：HTTP服务器的安装信息</p><p><code>d、实体首部字段</code>（请求报文与响应报文的的实体部分使用的首部字段）<br>Allow：资源可支持的HTTP方法<br>Content-Type：实体主类的类型<br>Content-Encoding：实体主体适用的编码方式<br>Content-Language：实体主体的自然语言<br>Content-Length：实体主体的的字节数<br>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p><code>HTTP缺点</code><br>1 通信使用明文（不加密）可能被窃听<br>2 不验证通信方身份 有可能遭遇伪装<br>3 无法证明报文完整性 有可能已遭篡改</p><p><code>HTTPS=HTTP+加密处理（一般是SSL安全通信线路）+认证+完整性保护</code><br>1 HTTPS协议需要申请到ca证书，一般免费证书较少，因而需要一定费用。<br>2 HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议。<br>3 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4 HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全<br>HTTPS通信过程：</p><p><code>HTTPS通信活动</code><br>-&gt; 客户端向服务端发送请求<br>-&gt; 服务端返回数字证书（hash（服务器身份和公钥）–&gt;信息摘要–&gt;CA私钥加密信息摘要–&gt;数字签名；数字签名+原始信息=数字证书）<br>-&gt; 客户端用自己的CA[主流的CA机构证书一般都内置在各个主流浏览器中]公钥去解密证书，验证信息摘要，如果证书有问题会提示风险<br>-&gt; 如果证书没问题客户端会生成一个对称加密的随机秘钥然后再和刚刚解密的服务器端的公钥对数据进行加密,然后发送给服务器端<br>-&gt; 服务器端收到以后会用自己的私钥对客户端发来的对称秘钥进行解密<br>-&gt; 之后双方就拿着这个对称加密秘钥来进行正常的通信</p><p><code>HTTP局限</code><br>SSL 慢：处理通信量增加，通信慢；处理速度慢，SSL必须进行加密处理，消耗了大量的CPU及内存资源，负载增强<br>SSL解决方案：使用SSL加速器（专用服务器）</p><h3 id="SSL-TSL加密"><a href="#SSL-TSL加密" class="headerlink" title="SSL/TSL加密"></a>SSL/TSL加密</h3><p><code>SSL (Secure Socket Layer)</code><br>SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。<br>SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。<br>使用：<br>　　1）认证用户和服务器，确保数据发送到正确的客户机和服务器；<br>　　2）加密数据以防止数据中途被窃取；<br>　　3）维护数据的完整性，确保数据在传输过程中不被改变。</p><p><code>TLS 协议</code><br>TLS(Transport Layer Security Protocol)：<br>安全传输层协议 ：TLS记录协议是一种分层协议。每一层中的信息可能包含长度、描述和内容等字段。记录协议支持信息传输、将数据分段到可处理块、压缩数据、应用MAC 、加密以及传输结果等。对接收到的数据进行解密、校验、解压缩、重组等，然后将它们传送到高层客户机。TLS连接状态指的是TLS记录协议的操作环境。它规定了压缩算法、加密算法和MAC算法。TLS记录层从高层接收任意大小无空块的连续数据。密钥计算：记录协议通过算法从握手协议提供的安全参数中产生密钥、 IV 和MAC密钥。<br>TLS 握手协议由三个子协议组构成，允许对等双方在记录层的安全参数上达成一致、自我认证、例示协商安全参数、互相报告出错条件。</p><p><code>TLS&amp;SSL</code><br>TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS 在SSL v3.0 的基础上，提供了以下增强内容：<br>1）更安全的MAC算法<br>2）更严密的警报<br>3）“灰色区域”规范的更明确的定义<br><code>TLS对于安全性的改进</code><br>1）对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。<br>2）增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。<br>3）改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。<br>4）一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。<br>5）特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。</p><h2 id="Web攻击技术-详见白帽子讲Web安全"><a href="#Web攻击技术-详见白帽子讲Web安全" class="headerlink" title="Web攻击技术  详见白帽子讲Web安全"></a>Web攻击技术  <code>详见白帽子讲Web安全</code></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;HTTP特性&quot;&gt;&lt;a href=&quot;#HTTP特性&quot; class=&quot;headerlink&quot; title=&quot;HTTP特性&quot;&gt;&lt;/a&gt;HTTP特性&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;HTTP 是一个属于应用层的面向对象的协议，HTTP 协议一共有五大特点
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>关于Raid0,Raid1,Raid3,Raid5(6),Raid10（0+1/1+0）的总结</title>
    <link href="http://yoursite.com/2018/09/15/%E5%85%B3%E4%BA%8ERaid0,Raid1,Raid3,Raid5(6),Raid10%EF%BC%880+1_1+0%EF%BC%89%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/15/关于Raid0,Raid1,Raid3,Raid5(6),Raid10（0+1_1+0）的总结/</id>
    <published>2018-09-15T04:12:59.000Z</published>
    <updated>2018-09-15T16:45:43.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RAID0-条带化，串連-Striping-硬盘数-gt-2"><a href="#RAID0-条带化，串連-Striping-硬盘数-gt-2" class="headerlink" title="RAID0 - 条带化，串連 (Striping) 硬盘数&gt;=2"></a><a href="https://www.freebsd.org/doc/zh_TW/books/handbook/geom-striping.html" target="_blank" rel="noopener"><code>RAID0 - 条带化，串連 (Striping) 硬盘数&gt;=2</code></a></h2><h3 id="定义-多磁盘数据分组同步读写-读写速度为单盘的X倍"><a href="#定义-多磁盘数据分组同步读写-读写速度为单盘的X倍" class="headerlink" title="定义 多磁盘数据分组同步读写 读写速度为单盘的X倍"></a>定义 多磁盘数据分组同步读写 读写速度为单盘的X倍</h3><p>RAID级别中的存储性能最高。将多个磁盘并列起来，成为一个大磁盘 <code>raid0</code>，将连续的数据分散到多个磁盘上存取，系统有数据请求就可以被多个磁盘并行的执行，每个磁盘执行属于它自己的那部分数据请求。这种数据上的并行操作可以充分利用总线的带宽，显著提高磁盘整体存取性能。<br><a href="https://blog.csdn.net/mao0514/article/details/38519027" target="_blank" rel="noopener">raid功能中spanning和striping模式有什么区别?</a><br><img src="https://www.freebsd.org/doc/zh_TW/books/handbook/geom/striping.png" alt="此处输入图片的描述"></p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>系统向三个磁盘组成的逻辑硬盘（RAID0磁盘组）发出的I/O数据请求被转化为3项操作，其中的每一项操作都对应于一块物理硬盘。通过建立RAID 0，原先顺序的数据请求被分散到所有的三块硬盘中同时执行。从理论上讲，三块硬盘的并行操作使同一时间内磁盘读写速度提升了3倍。 但由于总线带宽等多种因素的影响，实际的提升速率肯定会低于理论值，但是，大量数据并行传输与串行传输比较，提速效果显著显然毋庸置疑。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>1、读写性能高，非常适合于视频、图像的制作和编辑<br>2、安全性能低，不支持数据冗余，无容错功能，不适用于关键任务环境<br>3、磁盘空间使用率：100%，成本最低<br>4、在 RAID0 串連中的每個磁碟必須要相同大小</p><h2 id="RAID1-Block-鏡像-Mirroring-硬盘数-gt-2"><a href="#RAID1-Block-鏡像-Mirroring-硬盘数-gt-2" class="headerlink" title="RAID1 - Block 鏡像 (Mirroring) 硬盘数&gt;=2"></a><a href="https://www.freebsd.org/doc/zh_TW/books/handbook/geom-mirror.html" target="_blank" rel="noopener"><code>RAID1 - Block 鏡像 (Mirroring) 硬盘数&gt;=2</code></a></h2><h3 id="定义-多磁盘同数据同步写读-读写速度与单盘相同"><a href="#定义-多磁盘同数据同步写读-读写速度与单盘相同" class="headerlink" title="定义 多磁盘同数据同步写读 读写速度与单盘相同"></a>定义 多磁盘同数据同步写读 读写速度与单盘相同</h3><p>RAID 1通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能。</p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>将一个两块硬盘所构成RAID磁盘阵列，其容量仅等于一块硬盘的容量，因为另一块只是当作数据“镜像”。读只能在一块磁盘上进行，并不会进行并行读取，性能取决于硬盘中较快的一块。写的话通常比单块磁盘要慢，虽然是并行写，即对两块磁盘的写入是同时进行的，但因为要比较两块硬盘中的数据，所以性能比单块磁盘慢。<br><img src="https://img-blog.csdn.net/20170225143536108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3B1ZXJfSU8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="此处输入图片的描述"></p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>1、磁盘的利用率却只有50%，磁盘利用率最低，成本最高<br>2、数据冗余备份，容错，数据安全性高；当故障发生时，系统可自动切换到镜像磁盘，无需重组数据<br>3、读性能：只能在一个磁盘上读取，取决于磁盘中较快的那块盘<br>4、写性能：两块磁盘都要写入，虽然是并行写入，但因为要比对，故性能单块磁盘慢。<br>5、支持“热交换”，就是说阵列中硬盘的移除或替换可以在系统运行时进行，无须中断退出系统。</p><h2 id="RAID3-位元級串連與獨立奇偶校驗-校验存储与一个盘-硬盘数-gt-3"><a href="#RAID3-位元級串連與獨立奇偶校驗-校验存储与一个盘-硬盘数-gt-3" class="headerlink" title="RAID3 - 位元級串連與獨立奇偶校驗 校验存储与一个盘 硬盘数&gt;=3"></a><a href="https://www.freebsd.org/doc/zh_TW/books/handbook/geom-raid3.html" target="_blank" rel="noopener"><code>RAID3 - 位元級串連與獨立奇偶校驗 校验存储与一个盘 硬盘数&gt;=3</code></a></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>RAID 3是把数据分成多个“块”，按照一定的容错算法，存放在N+1个硬盘上，实际数据占用的有效空间为N个硬盘的空间总和，而第N+1个硬盘上存储的数据是校验容错信息</p><h3 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="http://ww2.sinaimg.cn/mw690/7178f37egw1eoohf6eqr3j20dc04y75j.jpg" alt="此处输入图片的描述"><br>当这N+1个硬盘中的其中一个硬盘出现故障时，从其它N个硬盘中的数据也可以恢复原始数据，这样，仅使用这N个硬盘也可以带伤继续工作（如采集和回放素材），当更换一个新硬盘后，系统可以重新恢复完整的校验容错信息。由于在一个硬盘阵列中，多于一个硬盘同时出现故障率的几率很小，所以一般情况下，使用RAID3，安全性是可以得到保障的。</p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>1、写入操作多磁盘并行进行，但每个数据盘写入数据，都需要同时重写校验盘中的相关信息，经常执行写入，会导致校验盘负载压力大<br>2、更加适合应用于那些写入操作较少，读取操作较多的应用环境，例如 数据库和WEB服务器等</p><h2 id="Raid5-分布式奇偶校验-硬盘数-gt-3"><a href="#Raid5-分布式奇偶校验-硬盘数-gt-3" class="headerlink" title="Raid5 分布式奇偶校验 硬盘数&gt;=3"></a><code>Raid5 分布式奇偶校验 硬盘数&gt;=3</code></h2><p><img src="https://images2015.cnblogs.com/blog/576154/201611/576154-20161124225904331-1146819836.jpg" alt="此处输入图片的描述"></p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>RAID 5是RAID 0和RAID1的折中方案。RAID5具有和RAID0相近似的数据读取速度，只是多了一个奇偶校验信息，写入数据的速度比对单个磁盘进行写入操作稍慢。</p><h3 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h3><p>RAID5把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且是分别存储于不同的磁盘上，其中任意N-1块磁盘上都存储完整的数据，也就是说有相当于一块磁盘容量的空间用于存储奇偶校验信息。当RAID5的一个磁盘发生损坏后，不会影响数据的完整性，从而保证了数据安全。当损坏的磁盘被替换后，RAID还会自动利用剩下奇偶校验信息去重建此磁盘上的数据，来保持RAID5的高可靠性。</p><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>1、磁盘空间利用率：(N-1)/N，即只浪费一块磁盘用于奇偶校验。存储成本相对较低<br>2、(n-1)*单块磁盘的读性能，和RAID0相近似的数据读取速度<br>3、写入数据的速度比对单个磁盘进行写入操作稍慢<br>4、高可靠性。奇偶校检与数据分别都存储不同盘，损坏时，可以自动重建。只允许一块磁盘损坏。</p><p>附 <code>Raid6</code><br>类似RAID5两组奇偶校验信息块，两个独立的奇偶系统使用不同的算法， 数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。相对于RAID 5有更大的“写损失”，因此“写性能”非常差。</p><h2 id="Raid10：RAID1-0和RAID0-1-硬盘-gt-4-偶数）"><a href="#Raid10：RAID1-0和RAID0-1-硬盘-gt-4-偶数）" class="headerlink" title="Raid10：RAID1+0和RAID0+1    硬盘&gt;=4 (偶数）"></a><code>Raid10：RAID1+0和RAID0+1    硬盘&gt;=4 (偶数）</code></h2><p><code>Raid10 镜象阵列条带</code> 先做镜像(1)，再做条带(0)<br><strong>可以理解为两个raid0同步</strong><br><img src="http://ww1.sinaimg.cn/mw690/7178f37egw1eoohf822ggj206y062dgr.jpg" alt="此处输入图片的描述"><br><code>Raid01</code> 先做条带(0)，再做镜像(1)<br><img src="http://ww4.sinaimg.cn/mw690/7178f37egw1eoohf594gvj207806bq3u.jpg" alt="此处输入图片的描述"></p><h3 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h3><p>Raid10其实结构非常简单，首先创建2个独立的Raid1，然后将这两个独立的Raid1组成一个Raid0，当往这个逻辑Raid中写数据时，数据被有序的写入两个Raid1中。磁盘1和磁盘2组成一个Raid1，磁盘3和磁盘4又组成另外一个Raid1;这两个Raid1组成了一个新的Raid0。</p><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><p>1、磁盘利用率50% 成本较高<br>2、<strong>安全性上RAID10要好于 RAID01</strong>，如图中所示，假设DISK0损坏，在RAID10中，只有DISK1 故障，整个RAID才失效。故障率为1/3。但在RAID01中，DISK0损坏后，左边的条带将无法读取，<strong>DISK2或DISK3两个盘中任何一个损坏</strong>，都会导致RAID失效。故障率2/3。<br>3、RAID01比起RAID10有着更快的读写速度</p><h2 id="Raid10-与-Raid5-比较"><a href="#Raid10-与-Raid5-比较" class="headerlink" title="Raid10 与 Raid5 比较"></a>Raid10 与 Raid5 比较</h2><p>1、<a href="http://blog.51cto.com/jiebers/1334486" target="_blank" rel="noopener">RAID5和RAID10，哪种RAID更适合你(上)</a><br>2、<a href="http://blog.51cto.com/jiebers/1334487" target="_blank" rel="noopener">RAID5和RAID10，哪种RAID更适合你(下)</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/ivictor/p/6099807.html" target="_blank" rel="noopener">https://www.cnblogs.com/ivictor/p/6099807.html</a><br><a href="http://blog.jobbole.com/83808/" target="_blank" rel="noopener">http://blog.jobbole.com/83808/</a><br><a href="https://blog.csdn.net/spuer_io/article/details/57080239" target="_blank" rel="noopener">https://blog.csdn.net/spuer_io/article/details/57080239</a><br><a href="https://www.freebsd.org/doc/zh_TW/books/handbook/geom.html" target="_blank" rel="noopener">https://www.freebsd.org/doc/zh_TW/books/handbook/geom.html</a><br><a href="http://blog.51cto.com/jiebers/1334486" target="_blank" rel="noopener">http://blog.51cto.com/jiebers/1334486</a><br><a href="http://blog.51cto.com/jiebers/1334487" target="_blank" rel="noopener">http://blog.51cto.com/jiebers/1334487</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RAID0-条带化，串連-Striping-硬盘数-gt-2&quot;&gt;&lt;a href=&quot;#RAID0-条带化，串連-Striping-硬盘数-gt-2&quot; class=&quot;headerlink&quot; title=&quot;RAID0 - 条带化，串連 (Striping) 硬盘数&amp;gt
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>XPath</title>
    <link href="http://yoursite.com/2018/09/10/XPath/"/>
    <id>http://yoursite.com/2018/09/10/XPath/</id>
    <published>2018-09-10T10:44:29.000Z</published>
    <updated>2018-09-15T16:57:31.541Z</updated>
    
    <content type="html"><![CDATA[<p>XPath is a major element in the XSLT standard. XPath can be used to navigate through elements and attributes in an XML document. XPath stands for XML Path Language. XPath uses “path like” syntax to identify and navigate nodes in an XML document.<br><img src="https://app.yinxiang.com/shard/s16/res/50865645-8af3-42e4-a21b-e2f16a3e0509/XPath.png" alt="XPath"></p><p><a href="https://app.yinxiang.com/shard/s16/res/9b3360b6-a6a2-46d7-8b57-aa81777eaa1c/XPath.html" target="_blank" rel="noopener">HtmL文件下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;XPath is a major element in the XSLT standard. XPath can be used to navigate through elements and attributes in an XML document. XPath st
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Github Pages +Hexo搭建个人博客</title>
    <link href="http://yoursite.com/2018/08/13/Github%20Pages%20+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/08/13/Github Pages +Hexo搭建个人博客/</id>
    <published>2018-08-13T04:27:29.000Z</published>
    <updated>2018-08-13T04:40:12.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备（以本教程为例）"><a href="#环境准备（以本教程为例）" class="headerlink" title="环境准备（以本教程为例）"></a>环境准备（以本教程为例）</h1><hr><ul><li>win10专业版 </li><li>Git 2.14.3Windows.1 </li><li>Node.js 10.8.0.0 </li><li>sublime编辑器</li></ul><p>注意：在Windows下安装完成后，git如果是在之前就安装好的，需重启才能使用npm命令<br> Git安装选项解释见：<br><a href="https://blog.csdn.net/ainuser/article/details/77609180" target="_blank" rel="noopener">https://blog.csdn.net/ainuser/article/details/77609180</a></p><h1 id="环境部署-在GitHub上创建Github-Pages项目"><a href="#环境部署-在GitHub上创建Github-Pages项目" class="headerlink" title="环境部署-在GitHub上创建Github Pages项目"></a>环境部署-在GitHub上创建Github Pages项目</h1><hr><h2 id="注册Github"><a href="#注册Github" class="headerlink" title="注册Github"></a>注册Github</h2><h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>点击“New”新建 “Repository”，这里一定要命名为“username.github.io”，然后选择Public，公开是免费的。<br>Github会识别并自动将该仓库设为Github Pages。用户主页是唯一的，填其他名称只会被当成普通项目。</p><h2 id="关联Git与GitHub"><a href="#关联Git与GitHub" class="headerlink" title="关联Git与GitHub"></a>关联Git与GitHub</h2><p>1）准备SSH Key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/.ssh  #根目录下检查本地是否本身存在SSH key</span><br><span class="line">rm -rf ~/.ssh #若原本存在，则清除本地原有的SSH key或者在后面生成SSH key的时候对原ssh进行覆盖操作</span><br><span class="line">git config --global user.name &quot;&lt;your_name&gt;&quot;  #设置Git登录的用户名，与github账户无关，做好记录</span><br><span class="line">git config --global user.email &quot;&lt;your_email&gt;&quot;  #设置Git登录的邮箱，与github账户无关，做好记录</span><br><span class="line">ssh-keygen -t ras -C &quot;&lt;your_github_email&gt;&quot;    #生成SSHkey，按照提示Enter，可不设置密码，设置密码后每当执行push操作时都需要输入密码，此处不设置，直接生成即可</span><br><span class="line">ls -al ~/.ssh  #查看生成的SSH key文件：id_rsa、id_rsa.pub</span><br><span class="line">cat ~/.ssh/id_rsa.pub #查看SSH key</span><br></pre></td></tr></table></figure></p><p>2）添加SSH key：<br>Personal Setting &gt; SSH and GPG keys&gt;New SSH key<br>Title：随意即可<br>Key：按照提示复制，将准备好的SSH key全部复制粘贴过来</p><p>3）SSH key测试连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ssh git@github.com #根目录下运行命令即可，不需要修改该命令的参数</span><br><span class="line"> #如果设置了密码会出现这一行：Enter passphrase for key &apos;/c/Users/llp/.ssh/id_rsa&apos;:</span><br><span class="line">PTY allocation request failed on channel 0</span><br><span class="line">Hi llplmlyd! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">Connection to github.com closed.#这里表示已经连接成功</span><br></pre></td></tr></table></figure></p><h1 id="Hexo建站"><a href="#Hexo建站" class="headerlink" title="Hexo建站"></a>Hexo建站</h1><hr><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli  #根目录下运行即可</span><br></pre></td></tr></table></figure><h2 id="本地新建博客站点文件夹-lt-your-blog-name-gt"><a href="#本地新建博客站点文件夹-lt-your-blog-name-gt" class="headerlink" title="本地新建博客站点文件夹&lt;your_blog_name&gt;"></a>本地新建博客站点文件夹&lt;your_blog_name&gt;</h2><h2 id="初始化建站"><a href="#初始化建站" class="headerlink" title="初始化建站"></a>初始化建站</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;your_blog_name&gt; #进入站点文件夹，tips：可以直接在站点文件夹下右键Gitbash即由git进入了文件夹内</span><br><span class="line">hexo init #在当前目录下初始化，注意一定要是空文件夹，否则会报错，无法初始化</span><br><span class="line">npm install #开始初始化安装hexo各配置文件</span><br></pre></td></tr></table></figure><p>初始化结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p><p>有时候会有一些其他的文件如：package-lock.json等</p><h2 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置_config.yml"></a>配置_config.yml</h2><p>配置文件修改可以借助编辑器进行修改，主要修改以下几个字段</p><p> <strong><code>#Site</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> #Site</span><br><span class="line">title #博客标题</span><br><span class="line">subtitle #博客副标题</span><br><span class="line">description #博客描述</span><br><span class="line">author #作者</span><br><span class="line">language 按照所选择主题进行设置，此处先默认处理</span><br></pre></td></tr></table></figure></p><p><strong><code>#Directory</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Directory</span><br><span class="line">#如果是站点即博客文件夹，则采取默认配置即可；如果是其他站点下的子文件夹则须修改</span><br><span class="line">#参考https://hexo.io/zh-cn/docs/configuration</span><br></pre></td></tr></table></figure></p><p><strong><code>## Themes</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next #主题根据自己使用的主题所在的文件夹名字修改</span><br></pre></td></tr></table></figure></p><p><strong><code># Deployment</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment 部署Hexo与Github关联推送</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: ssh://git@github.com/[githubname]/[库名].github.io</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></p><p><strong><code># Search</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 手动添加本地搜索功能字段</span><br><span class="line"># Search</span><br><span class="line"># Local Search: http://theme-next.iissnan.com</span><br><span class="line">search:</span><br><span class="line">    path: search.xml</span><br><span class="line">    field: post</span><br><span class="line">    format: html</span><br><span class="line">    limit: 10000</span><br></pre></td></tr></table></figure></p><h2 id="主题选择与配置"><a href="#主题选择与配置" class="headerlink" title="主题选择与配置"></a>主题选择与配置</h2><p>1）在hexo上下载解压喜欢的主题到本地<br><a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>2）复制该主题文件夹到：站点文件夹/themes<br>3）修改 _config.yml 中的## Themes<br>4）验证是否启用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt; #在站点根目录下gitbash输入，layout可不填，默认为post</span><br><span class="line">$ hexo s --debug</span><br><span class="line">INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br><span class="line">#选中地址右键实时预览</span><br></pre></td></tr></table></figure></p><p>5）主题配置文件修改<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a><br>① 主题 Scheme设定 &gt; 设置 语言(站点配置文件中修改)<br>② Menu 菜单设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Value before `||` delimeter is the target link.</span><br><span class="line"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.</span><br><span class="line">menu:</span><br><span class="line">home: / || home #首页</span><br><span class="line">about: /about/ || user  #关于</span><br><span class="line">tags: /tags/ || tags  #标签</span><br><span class="line">categories: /categories/ || th  #目录</span><br><span class="line">archives: /archives/ || archive #归档</span><br></pre></td></tr></table></figure></p><p>③ Sidebar 侧栏设置：默认<br>④ Avatar 头像设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将使用的头像图片调整成正方形并置入</span><br><span class="line">#[站点文件夹]\themes\next\source\images</span><br><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source/images): /images/avatar.gif</span><br><span class="line"># in site directory(source/uploads): /uploads/avatar.gif</span><br><span class="line">avatar: /images/your_avatar.jpg #文件名与后缀需完全对应</span><br></pre></td></tr></table></figure></p><p>⑤ Social Links  添加社交连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Social Links.</span><br><span class="line">social:</span><br><span class="line">     Google: https://plus.google.com/yourname || google</span><br></pre></td></tr></table></figure></p><p>⑥ links 友情链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links:</span><br><span class="line">    中文: 网址链接</span><br></pre></td></tr></table></figure></p><p>⑦添加评论功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Valine.</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># more info please open https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">    enable: true</span><br><span class="line">    appid: your appid</span><br><span class="line">    appkey: appkey</span><br></pre></td></tr></table></figure></p><p>⑧添加阅读量统计、评论量统计<br>本文采用leancloud第三方插件<br><a href="http://theme-next.iissnan.com/getting-started.html#leanclound-page-views" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html#leanclound-page-views</a><br>注册leancloud获得AppleID 和AppleKey<br>并在leancloud上添加两类class：Counter和Comments<br><a href="https://leancloud.cn/" target="_blank" rel="noopener">https://leancloud.cn/</a><br>在主题配置文件中设置AppleID 和AppleKey，</p><p>⑨ 添加 访问量统计<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span><br><span class="line">busuanzi_count:</span><br><span class="line">    # count values only if the other configs are false</span><br><span class="line">    enable: true</span><br><span class="line">    # custom uv span for the whole site</span><br><span class="line">    site_uv: true</span><br><span class="line">    site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt; 访客数&lt;/i&gt;</span><br><span class="line">    site_uv_footer: 人次</span><br><span class="line">    # custom pv span for the whole site</span><br><span class="line">    site_pv: true</span><br><span class="line">    site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt; 总访问量&lt;/i&gt;</span><br><span class="line">    site_pv_footer: 次</span><br><span class="line">    # custom pv span for one page only</span><br><span class="line">    page_pv: true</span><br><span class="line">    page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt; 总阅读量&lt;/i&gt;</span><br><span class="line">    page_pv_footer: 次</span><br></pre></td></tr></table></figure></p><p>⑩ 添加标签<br><a href="http://theme-next.iissnan.com/theme-settings.html#tags-page" target="_blank" rel="noopener">http://theme-next.iissnan.com/theme-settings.html#tags-page</a></p><p>6）新建目录<br>博客中的关于、标签和分类等栏目无文件夹，需要个人手动创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories [栏目英文名称]</span><br></pre></td></tr></table></figure></p><p>注意：要添加标签和自己新建目录之后侧栏才会显示出该数量</p><h2 id="生成与部署到Github上"><a href="#生成与部署到Github上" class="headerlink" title="生成与部署到Github上"></a>生成与部署到Github上</h2><p>在站点目录下右键gitbash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s --debug #可在各项详细配置完成后先进行测试</span><br><span class="line">INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br><span class="line">$ hexo clean  #可以清除缓存，再进行测试</span><br><span class="line">$ hexo generate #简写为hexo g，生成静态文件，文件位于public文件夹中</span><br><span class="line">$ hexo deploy    #简写为hexo d，部署网站到Github上，#可以生成与部署联用 hexo g -d 表示生成后立刻部署到github上</span><br></pre></td></tr></table></figure><p>注意：这里不需要使用到Git 与remote的同步与push命令之类的，请不要强行push站点文件夹，使用hexo d只会将public文件夹与仓库同步，配置文件仍保留在本地。</p><p>参考链接：<br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a><br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a><br><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/third-party-services.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境准备（以本教程为例）&quot;&gt;&lt;a href=&quot;#环境准备（以本教程为例）&quot; class=&quot;headerlink&quot; title=&quot;环境准备（以本教程为例）&quot;&gt;&lt;/a&gt;环境准备（以本教程为例）&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;win10专业版 &lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Blog" scheme="http://yoursite.com/categories/Blog/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux运维基础(一)</title>
    <link href="http://yoursite.com/2018/08/09/Linux%E5%AE%89%E5%85%A8%E8%BF%90%E7%BB%B4%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/09/Linux安全运维基础（一）/</id>
    <published>2018-08-09T02:12:29.000Z</published>
    <updated>2018-08-13T04:51:25.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-虚拟机的使用"><a href="#1-虚拟机的使用" class="headerlink" title="1 虚拟机的使用"></a><strong>1 虚拟机的使用</strong></h2><p>创建虚拟机<br>磁盘：虚拟机中文件形式存在（镜像文件）<br>ifconfig 查看设置<br>网络配置：vnet8，桥接模式<br>vnet1：仅宿主机模式</p><h2 id="2-操作系统概念"><a href="#2-操作系统概念" class="headerlink" title="2 操作系统概念"></a><strong>2 操作系统概念</strong></h2><p>内存，寻址空间，平面寻址，三维寻址<br>linux版本号(内核版本号):三部分组成:</p><p>A.B.C<br>A:主版本号<br>B:次版本号(奇数:开发版本 偶数:发行版本)<br>C:修订版本号(修订次数)</p><p>内核版本:3.6.28 3时主版本号 6:次版本号 28:修订了28次<br>先把3.6.28拷贝一份进行研发,并把版本号升级为3.7.01(在3.6.28基础上修复漏洞,开发新功能)<br>3.8.XX:下一个发行版本<br>开发–内测(修复漏洞,开发新功能)–公测–正式版本生成(正式上线)</p><p>~当前用户所在目录：代表用户宿主目录</p><h2 id="3-Linux设计哲学思想"><a href="#3-Linux设计哲学思想" class="headerlink" title="3 Linux设计哲学思想"></a><strong>3 Linux设计哲学思想</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">shell：使用者与计算机交互的接口，人输入命令给shell，shell传递给内核</span><br><span class="line">         Linux支持的shell：bash：默认使用的shell</span><br><span class="line">                                      ksh</span><br><span class="line">                                      csh</span><br><span class="line">xshell：远程连接linux  还有CRT</span><br><span class="line">         其使用方法：在同一个网段中，然后即可使用Xshell软件：ssh </span><br><span class="line">```         </span><br><span class="line">IP→输入用户名，密码</span><br><span class="line">内核作用：无论从图形界面/还是字符界面 都可以返回结果。</span><br><span class="line">1、进程管理：要执行的任务；2、内存管理；3、文件系统：存储设备上村塾数据的方式方法</span><br><span class="line">Linux ext3/4/，xfs等；4、网络功能：管理IP地址信息等；5、硬件驱动；6、安全功能；</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>## Linux设计思想</span><br><span class="line">1:有很多的小程序组成,每个小程序完成单一的功能,实现复杂的任务(http服务需要安装很多小组件)</span><br><span class="line">2:一切皆文件:所有的外围设备(硬件)或者其他程序</span><br><span class="line">3:尽量避免捕获用户接口</span><br><span class="line">4:配置文件保存为纯文本格式(可以用文本编辑器编辑 vim)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>## Linux终端:多用户多任务系统</span><br><span class="line">6个终端:ctrl+alt+F1-F6</span><br><span class="line">切换图形界面:ctrl+alt+F7</span><br><span class="line">切换用户:su(switch user)</span><br><span class="line">su命令:当root用户切换到普通用户时,不需要普通用户的密码;而当普通用户切换到root用户时,需要提供root用户密码</span><br><span class="line">root student</span><br><span class="line">```shell</span><br><span class="line"><span class="meta">#</span> su user_name</span><br><span class="line"><span class="meta">$</span> exit 退出当前用户</span><br></pre></td></tr></table></figure><p>命令格式<br>命令字 [选项] [参数]:中括号表示可以省略，例如 ls -a /ect/<br>命令字:唯一的,实现某一项功能<br>选项:修改命令的执行方式(实现特定功能)<br>长选项:–引导,是一个单词(多个长选项不能组合)<br>短选项:-引导,是一个字符(多个短选项可以组合)<br>参数:命令作用的对象</p><h2 id="4-高效获取命令帮助信息"><a href="#4-高效获取命令帮助信息" class="headerlink" title="4 高效获取命令帮助信息"></a><strong>4 高效获取命令帮助信息</strong></h2><h3 id="Linux命令分类"><a href="#Linux命令分类" class="headerlink" title="Linux命令分类"></a>Linux命令分类</h3><p>内部命令:shell自带的命令<br>外部命令:在Linux文件系统中存在一个应用程序</p><h3 id="type-查看Linux命令类型"><a href="#type-查看Linux命令类型" class="headerlink" title="type:查看Linux命令类型"></a>type:查看Linux命令类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[command] is a shell builtin:buildin关键字说明该命令是内部命令</span><br><span class="line">mkdir is /bin/mkdir:有路径显示(外部命令)</span><br></pre></td></tr></table></figure><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>绝对路径:从根(/)开始的路径是绝对路径,linux系统中只有一个根<br>相对路径:以所处的工作目录为参照点 (.代表当前路径 ..代表上一级路径 ~代表登录用户的宿主目录)</p><h3 id="ls-list-列出目录"><a href="#ls-list-列出目录" class="headerlink" title="ls(list):列出目录"></a>ls(list):列出目录</h3><p>-l(–long):以长格式显示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-------. 1 root root 1207 Nov 6 18:51 anaconda-ks.cfg</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">第一位:文件类型</span><br><span class="line">    -:代表普通文件(file)</span><br><span class="line">    d:代表目录(directory)</span><br><span class="line">    b:块设备(block):如硬盘,U盘等</span><br><span class="line">    c:字符设备(char):如键盘等</span><br><span class="line">    :套接字文件(socket)</span><br><span class="line">    p:命名管道(pipe)</span><br><span class="line">    l:符号链接文件(symbolic link file )</span><br><span class="line">第二到十位:权限位(rwx:读写执行)</span><br><span class="line">    234位:文件属主权限(owner)</span><br><span class="line">     567位:文件属组权限(group)</span><br><span class="line">    8910位:其他用户权限(other)</span><br><span class="line">1:  代表文件硬链接的次数</span><br><span class="line">第一个root:代表文件属主(owner)</span><br><span class="line">第二个root:代表文件属组(group)</span><br><span class="line">1207:文件的大小</span><br><span class="line">Nov 6 18:51:文件最后被访问的时间戳(stat命令查看文件时间戳)</span><br><span class="line">文件的时间戳:</span><br><span class="line">    access:访问的时间戳</span><br><span class="line">    Modify:文件被修改时间戳(修改文件数据:添加删除数据等)</span><br><span class="line">    change:文件被更改时间戳(更改文件属性)</span><br><span class="line">    anaconda-ks.cfg:文件名</span><br></pre></td></tr></table></figure><h3 id="ls命令字所带选项用法"><a href="#ls命令字所带选项用法" class="headerlink" title="ls命令字所带选项用法"></a>ls命令字所带选项用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-h:为文件大小添加单位，可以与ls -l联用，即ls -lh</span><br><span class="line">-a:显示目录下所有文件(包括. .. 以.开始的隐藏文件)</span><br><span class="line">-A:和-a相同,但是不显示.和..</span><br><span class="line">-R:递归显示目录中的内容(一并显示子目录中所有内容)</span><br><span class="line">-r:逆序显示目录内容</span><br><span class="line">-i:显示文件所在的inode节点(index node)</span><br><span class="line">-d:显示目录本身的属性</span><br><span class="line">递归显示-R：Recrusion</span><br><span class="line">逆序显示文件内容：-r：reverse</span><br></pre></td></tr></table></figure><h3 id="环境变量-内存中的命名空间"><a href="#环境变量-内存中的命名空间" class="headerlink" title="环境变量:内存中的命名空间"></a>环境变量:内存中的命名空间</h3><p>PATH变量:存放系统命令路径,以冒号隔开<br>查看PATH变量:echo $PATH(Linux命令严格区分大小写)存在的路径<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure></p><p>如果在以上路径中没有找到相关命令(该命令为外部命令),提示用户command not found<br>如果一个命令在以上多个路径中存在,系统会按照从前往后的顺序查找,查找到该命令后,后面的路径的不在查找</p><p>hash:查看命令缓存及命中率</p><h3 id="Linux命令的帮助信息"><a href="#Linux命令的帮助信息" class="headerlink" title="Linux命令的帮助信息"></a>Linux命令的帮助信息</h3><pre><code>内部命令:help [command]外部命令:[command] --helpman:帮助(命令的使用说明书)(查看内部命令时,显示的是bash帮助信息)语法: man [command]</code></pre><p>上下方向键:翻行<br>enter:向下翻行<br>pagedown:向下翻页<br>pageup:向上翻页<br>/word:从上往下查找关键字<br>?word:从下往上查找关键字<br>q:退出当前帮助信息</p><h3 id="man目录说明"><a href="#man目录说明" class="headerlink" title="man目录说明"></a>man目录说明</h3><p>1:User Commands:普通用户命令(/bin /usr/bin /usr/local/bin):binary二进制<br>2:System Calls:系统调用库<br>3:C Library Functions:库调用<br>4:Devices and Special Files:设备或特殊文件(硬件设备)(硬件设备存放在/dev)<br>5:File Formats and Conventions:查看配置文件格式<br>6:Games et. Al.:游戏<br>7:Miscellanea:杂项<br>8:System Administration tools and Deamons:管理命令(/sbin /usr/sbin /usr/local/sbin)sbin:secret binary</p><p>which:查看命令所在的路径<br>whatis:查看命令所在的帮助信息目录,该命令在系统启动大约70分钟后会生成whatis的数据库,如果时间太短,该命令不会执行。<br>使用makewhatis(CentOS 6)初始化该命令,就不需要等待在CentOS 7中使用man的命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install man-pages</span><br></pre></td></tr></table></figure></p><h4 id="man使用说明"><a href="#man使用说明" class="headerlink" title="man使用说明"></a>man使用说明</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NAME:命令名称及简要用法</span><br><span class="line">SYNOPSIS:语法格式,可能包括一些选项的使用 如：ls -[Option]</span><br><span class="line">DESCRIPTION:命令和命令选项的详细说明</span><br><span class="line">Exit status:退出状态码</span><br><span class="line">AUTHOR:作者信息</span><br><span class="line">REPORTING BUGS(BUG):发现BUG时如何反馈信息</span><br><span class="line">COPYRIGHT:该命令的版权信息</span><br><span class="line">SEE ALSO:另外参照的帮助信息</span><br><span class="line">OPTIONS:说明该命令每一个选项的详细用法</span><br><span class="line">EXAMPLES:命令使用实例</span><br></pre></td></tr></table></figure><h4 id="man手册页目录"><a href="#man手册页目录" class="headerlink" title="man手册页目录"></a>man手册页目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/doc(工作中主要是查看内核信息)</span><br><span class="line">&lt;&gt;:必须使用的选项或参数,不可以省略</span><br><span class="line">[]:可是省略的选项或参数</span><br><span class="line">...:可以使用多个选项或参数</span><br><span class="line">|:代表多选一</span><br><span class="line">&#123;&#125;:分组,没有特殊意义</span><br></pre></td></tr></table></figure><h3 id="一些常用命令"><a href="#一些常用命令" class="headerlink" title="一些常用命令"></a>一些常用命令</h3><p>info:在线查看帮助,注重于命令历,版史权信息等<br>cd:change directory(切换目录)<br>    cd:不加选项,返回到当前用户的宿主目录<br>    -:返回到上一次的工作路径<br>    ~username:切换到username的宿主目录<br>pwd:print working directory:显示当前所处的工作目录</p><h2 id="5-Linux根文件系统"><a href="#5-Linux根文件系统" class="headerlink" title="5 Linux根文件系统"></a><strong>5 Linux根文件系统</strong></h2><blockquote><p>Linux目录结构是一个倒树形的：<br>最上面的是根，Linux只有一个根；Windows有多个根。而Linux的系统类型又多（发行产商较多），为统一每个系统下的文件目录，产生了一个标准，即FHS标准：希望用户可以了解已经安装的系统</p></blockquote><h3 id="FHS标准"><a href="#FHS标准" class="headerlink" title="FHS标准"></a>FHS标准</h3><p>文件系统分层结构标准（File System Hierarchy Standard）<br>FHS规定:/etc /bin /dev /lib /sbin五个目录必须要和根目录位于同一文件系统<br><a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard</a><br><a href="https://linux.cn/article-6132-1.html" target="_blank" rel="noopener">https://linux.cn/article-6132-1.html</a></p><h3 id="根目录下目录及子目录的作用"><a href="#根目录下目录及子目录的作用" class="headerlink" title="根目录下目录及子目录的作用"></a>根目录下目录及子目录的作用</h3><h4 id="根文件文件系统"><a href="#根文件文件系统" class="headerlink" title="根文件文件系统"></a>根文件文件系统</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(/):rootfs:root filesystem，主层次根</span><br><span class="line">/bin: 单用户二进制命令文件,存放命令</span><br><span class="line">/boot: 引导加载驱动，存放启动和内核相关文件</span><br><span class="line">/dev: 存放设备文件</span><br><span class="line">/etc: 存放应用程序的配置文件</span><br><span class="line">   /etc/ resolv.conf DNS配置地址</span><br><span class="line">   /etc/hosts Hosts信息</span><br><span class="line">   /etc/sysconfig 网络配置</span><br><span class="line">/home:普通用户的家目录,默认为/home/USERNAME</span><br><span class="line">/lib和/lib64:存放系统开机时需要用的函数库及/bin和/sbin命令调用函数库</span><br><span class="line">/lib/modules:存放内核相关的模块(驱动程序等)</span><br><span class="line">/media和/mnt:挂载点,/media挂载移动设备 /mnt挂载临时设备</span><br><span class="line">/opt:第三方软件存放目录(用户自行安装的软件存放处),现在一般安装到/usr/local下</span><br><span class="line">/proc:伪文件系统,数据存放在内存中,存放关于进程的相关信息，有CPU、内核的信息，系统调优的时候可以在此目录进行修改配置，</span><br><span class="line">/root:管理员的家目录</span><br><span class="line">/sbin:存放管理员使用的命令，只有管理员可执行</span><br><span class="line">/srv:service缩写,存放服务数据目录,如可以把www服务的网页存放到该目录</span><br><span class="line">/tmp:存放临时文件,所有用户都可以访问创建文件,但是每个用户只能删除自己的文件；一定时间后系统会删除</span><br><span class="line">/sys:伪文件系统,存放在内存中,记录内核相关的信息,包括目前加载内核模块和内核检测到的硬件设备等</span><br><span class="line">/usr:UNIX software resource:存放安装的应用程序</span><br><span class="line">   /usr/bin:普通用户使用的命令(和/bin区别是否与开机有关)</span><br><span class="line">   /usr/sbin: 网络服务器命令</span><br><span class="line">   /usr/lib和/usr/lib64: 包含各种应用程序函数库</span><br><span class="line">   /usr/share:存放共享文件目录(在线帮助文件,杂项,时区文件等)</span><br><span class="line">   /usr/include:存放头文件，比如C语言的头文件，安装软件的头文件</span><br><span class="line">   /usr/src:释放源代码目录</span><br><span class="line">/var: vary缩写,存放经常变动的文件,比如 志,mail等， 持续改变的各种文件存放位置 包括cache、mail、lock、log、mail、spool</span><br><span class="line">    /var/cache:存放应用程序运行时产生的缓存文件</span><br><span class="line">    /var/lib:程序运行时,需要使用的数据文件的存放目录，比如MySQL的文件即可能放在这里</span><br><span class="line">    /var/lock:设备或资源一次只能被一个应用程序使用,如果多应用程序会产生错误,因为要为设备或资源上锁(存放锁文件)</span><br><span class="line">    /var/log:存放日志目录(系统,用户登录,服务日志等)</span><br><span class="line">    /var/mail:存放个人电子邮件(系统报警产生邮件信息等)</span><br><span class="line">    /var/run:存放应用程序运行时PID文件(进程号.pid结尾)</span><br><span class="line">    /var/spool:存放队列数据,排队等待其他用户程序使用的数据,数据通常使用完成后会被删除</span><br><span class="line">./ sgml存放处理标准通用标记语言的配置文件</span><br><span class="line">./xml 处理xml的配置文件</span><br></pre></td></tr></table></figure><h3 id="bin、-sbin、-usr-bin三者区别"><a href="#bin、-sbin、-usr-bin三者区别" class="headerlink" title="/bin、/sbin、/usr/bin三者区别"></a>/bin、/sbin、/usr/bin三者区别</h3><p>/bin：存放的是系统启动时的二进制指令<br>/usr/bin：与开机无关</p><blockquote><p>The root file system is the file system contained on the same disk<br>partition on which the root directory is located; it is the filesystem<br>on top of which all other file systems are mounted as the system boots<br>up.<br>     根文件系统是包含在根目录所在的同一磁盘分区上的文件系统; 它是文件系统，在系统启动时安装所有其他文件系统。</p></blockquote><p>file命令:查看linux中文件类型<br>语法: file [options] file_name</p><h3 id="Linux文件名限制"><a href="#Linux文件名限制" class="headerlink" title="Linux文件名限制"></a>Linux文件名限制</h3><p>1:单个文件或目录的名称不能超过255字符<br>2:文件命中不能包含特殊字符(/ . - +等)</p><h3 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-:普通文件</span><br><span class="line">纯文本文件(ASCII):配置文件</span><br><span class="line">二进制文件(binary file): 命令</span><br><span class="line">数据格式文件(data):/var/log/wtmp</span><br><span class="line">d:目录文件</span><br><span class="line">l:链接文件:软链接文件</span><br><span class="line">设备文件:(/dev)</span><br><span class="line">b:block块设备</span><br><span class="line">c:character字符集设备:一次性读取,按顺序读取</span><br><span class="line">s:socket套接字文件:通常用在网络上数据连接: IP:PORT</span><br><span class="line">p:管道:特殊的文件类型,解决多个程序同时访问一个文件所造成的错误问题</span><br><span class="line">在Linux一个文件是否能被执行，和后缀扩展名没有很大关系，所以需要用到file来使用</span><br></pre></td></tr></table></figure><h2 id="6-Linux-常见命令"><a href="#6-Linux-常见命令" class="headerlink" title="6 Linux 常见命令"></a><strong>6 Linux 常见命令</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vim：vi 编辑创建文件，insert键入编辑文本，ESC退出编辑，":wq",write and quit，如果不想保存就直接 q就可以了</span><br><span class="line">cat &#123;abc.txt，def.txt，...&#125; /... 在...目录下同时创建几个...文件</span><br></pre></td></tr></table></figure><p>基本命令:ls cd pwd<br>学习内容:file cat cp mv rm mkdir touch tree which whereis<br>文件管理；目录管理；系统管理；网络管理等</p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法:file [options] [args]:查看文件类型(windows是用扩展名识别文件类型)</span><br><span class="line">-b:显示结果时,不显示文件名</span><br><span class="line">-c:显示执行file命令的执行过程(file是如何去判断文件类型),便于排错或分析file命令执行过程</span><br><span class="line">-i:输出MIME类型的字符串</span><br><span class="line">-z:显示压缩文件的内容</span><br><span class="line">-L:查看软链接对应文件的类型</span><br><span class="line">-f:查看文件中文件名的类型</span><br></pre></td></tr></table></figure><p>查看文本文件内容命令:cat more less head tail<br>Linux和Windows中文件内容行尾标记是不同的:<br>Linux中是以$为结尾<br>Windows中是以ENTER键结尾</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1:一次性查看整个文件 </span><br><span class="line">语法:cat [options] [args]</span><br><span class="line">2:从键盘输入创建一个新文件或向现有文件中添加新数据: </span><br><span class="line">新建新文件:cat &gt;new_file_name &lt;&lt;EOF //EOF:end of file</span><br><span class="line"><span class="meta">&gt;</span>Linux command //从键盘输入</span><br><span class="line"><span class="meta">&gt;</span>Uinx command //从键盘输入</span><br><span class="line"><span class="meta">&gt;</span>EOF //从键盘输入,以结束书写</span><br><span class="line">向现有文件中追加数据:</span><br><span class="line">cat &gt;&gt; file_name &lt;&lt; EOF</span><br><span class="line"><span class="meta">&gt;</span>CISP!</span><br><span class="line"><span class="meta">&gt;</span>CISSP!</span><br><span class="line"><span class="meta">&gt;</span>EOF</span><br><span class="line">3:把多个文件内容合并到一个文件输出:</span><br><span class="line">cat file1 file2 &gt; file3</span><br></pre></td></tr></table></figure><p>cat /etc/passwd /etc/shadow &gt; /root/user.txt<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-n:显示文件内容时同时显示行号,包括空行</span><br><span class="line">-b:和-n功能相同,但不包括空行</span><br><span class="line">-S:当文件中有多个空行时,合并为一个空行</span><br><span class="line">-E:在显示内容时,结尾添加$符号</span><br></pre></td></tr></table></figure></p><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>可以翻页查看文本文件内容<br>enter键:向下翻一行<br>空格键:向下翻一屏<br>ctrl+b:向上翻一屏<br>ctrl+f:向下翻一屏<br>=:显示当前的行号<br>v:调用vi编辑器<br>!command:调用shell执行命令<br>q:退出more命令</p><p><strong>more +num file_name //从num行开始查看文件内容</strong></p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>可以翻页查看文本文件内容<br>enter键:向下翻一行<br>空格键:向下翻一屏<br>pagedown:向下翻一屏<br>pageup:向上翻一屏<br>上下方向键:向上/向下翻一行<br>/word:在该文件中查找word关键字<br>n:查找下一个<br>N:查找上一个</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>连接多条命令,前一条命令输出结果作为后一条命令的输入条件, 管道符 | </p><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>默认查看文件文件的前十行<br>-n:查看文件文件前n行</p><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>默认查看文本文件的后十行<br>-n:查看文本文件的后n行<br>-f:动态查看文本文件内容,如动态查看日志: tail -f /var/log/messages<br>在任何位置均可进行查看，当系统有安装/服务启动关闭等行为时，会马上有记录出现</p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>复制文件或目录(copy简写)<br>语法:cp [options] [src_file] [des_file]<br>-f:force,强制复制文件或目录不进行提示<br>-r:递归复制目录<br>-s:为某个文件创建符号链接(软链接),而不是复制文件<br>-b:覆盖已有的文件前,对目标文件进行备份<br>-l:为文件创建硬链接,而不是复制文件<br>-p:复制文件时保留文件的原有属性<br>-d:当复制软链接文件时,把目标文件或目录也会创建为软链接,并指向最原始的文件<br>-i:覆盖目标文件前询问(cp = cp -i)</p><h3 id="mv-move"><a href="#mv-move" class="headerlink" title="mv: move"></a>mv: move</h3><p>移动或从命名文件和目录<br>(当原位置和目标位置是同一目录时,是重命名;当原位置和目标位置不是同一目录时,是移动)<br>-b:移动前先对源文件进行备份<br>-f:强制覆盖<br>-i:覆盖目标文件前询问<br>-t:将多个文件移动同一个目录(目标目录在前面,后面跟文件 mv -t [directory] file1 file2 …)</p><h3 id="rm-remove"><a href="#rm-remove" class="headerlink" title="rm: remove"></a>rm: remove</h3><p>删除文件或目录<br>-d:删除可能存在数据的目录<br>-f:强制删除<br>-i:删除前进行询问<br>-r:递归删除整个目录<br>-v:显示命令执行过程</p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>make directory,创建空目录<br>-m:创建目录时同时设置权限<br>-p:递归创建新目录<br>-v:显示创建目录的过程</p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>创建新文件或者修改文件时间戳<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a:只改变访问时间</span><br><span class="line">-c:不创建文件</span><br><span class="line">-d:使用指定时间戳创建新文件,而不是使用系统时间</span><br><span class="line">-t:使用指定格式时间戳创建新文件,而不是使用系统时间</span><br><span class="line">-f:解决与BSD系列Unix系统兼容性</span><br><span class="line">-m:只更改变动时间</span><br></pre></td></tr></table></figure></p><p>tree:查看目录树(tree = ls -R)<br>yum -y install tree</p><p>which:查找命令所在的路径<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whereis:查看命令所在的路径,源代码文件,帮助信息文件所在的文件</span><br><span class="line">-b:只查看文件所在的位置(等同于which命令)</span><br><span class="line">-m:只查看帮助信息所在的位置</span><br><span class="line">-s:支持看源代码所在的位置</span><br></pre></td></tr></table></figure></p><h2 id="7-Shell特性"><a href="#7-Shell特性" class="headerlink" title="7 Shell特性"></a><strong>7 Shell特性</strong></h2><p>安装进程树命令：yum install psmisc<br>pstree 进程树命令 pstree -p</p><p>###shell广义分类<br>GUI:包括GNOME KDE XFACE等<br>CLI:sh csh ksh bash等(Linux发行版本中,bash是默认使用的shell程序)</p><p>shell启动:当用户登录完成后,系统会自动启动shell程序<br>进程:应用程序的副本;使用PID区分(在系统中,一个进程只认为自己存在)<br>root student用户<br>shell:父shell程序和子shell程序(父子shell之间设置环境互相独立,互不影响)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells //查看当前系统所支持的shell程序</span><br><span class="line">yum -y install ksh csh //安装ksh,csh的shell程序</span><br><span class="line">exit //退出当前shell程序</span><br></pre></td></tr></table></figure></p><p>shell是一个程序</p><h3 id="bash特性"><a href="#bash特性" class="headerlink" title="bash特性"></a>bash特性</h3><h4 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史:"></a>命令历史:</h4><pre><code> Linux会自动记录系统过去执行的命令,并保存在内存的缓冲区中，在每个用户的家目录下,有个隐藏文件.bash_history保存命令历史 # history //查看linux的历史-c:清空命令历史-d:删除某一条命令历史-w:将命令历史保存到某个文件中变量:PATH命令路径变量HISTSIZE:命令历史大小变量$ echo $HISTSIZE //查看HISTSIZE变量的值,默认的命令历史是1000条命令历史使用技巧:!n:执行命令历史中的第n条命令(n是命令历史编号)!-n:执行命令历史中的倒数第n条命令(n是命令历史编号)!word:执行命令历史中最近一次以word开始的命令(word必须能够唯一的标识用户想执行的命令)!!:执行上一条命令!$:引用一个命令的最后一次参数ESC键(按完松开) 再按.键:引用一个命令的最后一次参数</code></pre><h4 id="命令行编辑："><a href="#命令行编辑：" class="headerlink" title="命令行编辑："></a>命令行编辑：</h4><p>ctrl+a:光标快速跳转到命令行的行首<br>ctrl+e:光标快速跳转到命令行的行尾<br>ctrl+u:快速删除光标位置到命令行行首的字符<br>ctrl+k:快速删除光标位置到命令行行尾的字符<br>ctrl+l:清屏(命令clear:清屏)</p><h4 id="命令行展开"><a href="#命令行展开" class="headerlink" title="命令行展开"></a>命令行展开</h4><pre><code> 双Tab可以显示与关键输入相关的所有命令 当有唯一识别度的时候，单Tab可以显示命令 $(COMMAND) 常用于shell脚本编程      3.1:命令补齐:在PATH变量搜索命令并补齐(PATH变量必须正常,输入要补齐命令的字符数一定能够唯一标识这条命令;tab键补齐)    按tab键两次,列出以某个字符开始的所有的命令    # echo $PATH //查看PATH变量的值    路径和文件补齐:在系统路径中查找    命令行补齐功能不能补齐选项     3.2:命令替换(经常用到shell脚本编程中) $(command)或者 `command`(两边是反撇号)    命令替换就是把命令中的子命令替换成子命令执行结果的过程# echo &quot;字符串&quot;&quot;&quot;(双引号):弱引用(可是实现变量的替换,把变量名替换为变量值)``(反撇号):命令引用&apos;&apos;(单引号):强引用(不能完成变量替换)     例如：     [root@localhost ~]# echo &apos;Directory is $(pwd).&apos;     Directory is $(pwd).     [root@localhost ~]# echo &quot;Directory is $(pwd).&quot;     Directory is /root.     单引号和双引号效果不一样，双引号执行命令，单引号不执行。</code></pre><h4 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h4><p>(alias定义的别名只在当前shell生效)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> alias COMM_ALIAS=COMMAND //只执行alias命令,列出系统中所有的命令别名</span><br><span class="line">注意:执行alias命令时,COMMAND最好用''(引号)引起来</span><br><span class="line">例如：alias cdnet='cd /etc/sysconfig/network-scripts'</span><br><span class="line"><span class="meta">#</span> unalias COMM_ALIAS //取消命令别名</span><br></pre></td></tr></table></figure></p><p>命令行通配:globbing<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">与正则表达类似</span><br><span class="line">*:匹配任意长度的任意字符</span><br><span class="line">?:匹配任意单个字符</span><br><span class="line">[]:匹配指定范围内的任意单个字符</span><br><span class="line">[ab] [a-m] [a-z] [A-Z] [a-zA-Z] [0-9] [a-zA-Z0-9]</span><br><span class="line">[^]:匹配指定范围外的任意单个字符</span><br><span class="line">[^a-z] [^0-9]</span><br><span class="line">使用示例：https://www.cnblogs.com/tdcqma/p/5853020.html</span><br><span class="line">[:space:]:表示空格</span><br><span class="line">[:punct:]:表示所有标点符号</span><br><span class="line">[:lower:]:表示所有小写字母</span><br><span class="line">[:upper:]:表示所有大写字母</span><br><span class="line">[:alpha:]:表示所有字母(包括大小写)</span><br><span class="line">[:digit:]:表示所有数字</span><br><span class="line">[:alnum:]:表示所有数字和大小写字母</span><br></pre></td></tr></table></figure></p><h3 id="IO输入输出重定向以及管道"><a href="#IO输入输出重定向以及管道" class="headerlink" title="IO输入输出重定向以及管道"></a>IO输入输出重定向以及管道</h3><p>计算机体系结构:<br>控制器:CPU,读取系统指令<br>运算器:CPU,运算<br>存储器:RAM(内部存储器:易失性存储器)<br>输入设备(Input):输入数据,如键盘,硬盘等<br>输出设备(Output):显示指令执行结果,如显示器,音响,硬盘等</p><h4 id="计算机总线bus"><a href="#计算机总线bus" class="headerlink" title="计算机总线bus"></a>计算机总线bus</h4><p>地址总线:负责内存寻址<br>数据总线:负责传输数据<br>控制总线:负责控制指令<br>寄存器:CPU中内部临时存储空间</p><p>I/O设备:负责计算机内部存储设备和外部存储设备(如硬盘,光盘,U盘等)进行交互的设备</p><p>程序:指令+数据<br>指令:有程序提供,负责加工数据<br>数据:系统中数据可以有多种来源,比如来自变量,来自文件,来自输入设备等</p><h4 id="系统默认数据来源"><a href="#系统默认数据来源" class="headerlink" title="系统默认数据来源"></a>系统默认数据来源</h4><p>当用户没有为指令指定数据来源时,系统要有默认的数据来源：<br>    标准输入输出设备:<br>    标准输入设备:键盘(stdin),文件描述符为0<br>    标准输出设备:显示器(stdout),文件描述符为1<br>    标准错误输出设备:显示器(stderr),文件描述符为2<br>三种数据流:<br>    标准输入数据流/标准输出数据流/标准错误输出数据流</p><p>当在Liunx中打开一个文件时,内核会反复调用,对于文件标识就很重要了,用文件描述符来标识文件,文件加载完成用数字标识<br>fd:file descriptor(文件描述符)</p><h4 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h4><p>把默认输入输出数据来源,重新定向到其他的文件或设备<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 输出重定向:</span><br><span class="line">    &gt;:覆盖输出重定向</span><br><span class="line">    &gt;&gt;:追加输出重定向</span><br><span class="line">    2&gt;:错误覆盖输出重定向</span><br><span class="line">    2&gt;&gt;:错误追加输出重定向</span><br><span class="line">    &amp;&gt;:混合覆盖输出重定向</span><br><span class="line">    &amp;&gt;&gt;:混合追加输出重定向</span><br><span class="line">2 输入重定向:</span><br><span class="line">    &lt;:输入重定向</span><br></pre></td></tr></table></figure></p><p>管道:连接多条命令,把前一条命令的输出结果作为后一条命令的输入条件(组合小程序,实现大功能)    <code>command1 | command2 | commad3 ....</code></p><p>tr:实现字符转换,不修改源文件,语法:tr [OPTION]… SET1 [SET2]<br>例如：<code>cat 文件 | tr &#39;a-z&#39; &#39;A-Z&#39;</code><br>tee: 将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的stdin<br><a href="http://man.linuxde.net/tee" target="_blank" rel="noopener">http://man.linuxde.net/tee</a><br>变量<br>编程</p><h2 id="8-用户"><a href="#8-用户" class="headerlink" title="8 用户"></a><strong>8 用户</strong></h2><p>&ensp;&ensp;&ensp;&ensp;Linux实现权限隔离机制(多用户)，用多用户分组实现。操作系统使用UID来识别用户，而如果同一个文件多个用户都有相同权限时，启用组GID。<br>操作系统识别用户:<br>&ensp;&ensp;&ensp;&ensp;用户:UID（管理员用户0；普通用户1000-65535；程序/系统用户1-999）<br>&ensp;&ensp;&ensp;&ensp;组:GID(逻辑容器:包含用户;实现多个用户对于某个文件或应用程序分配相同的权限)<br>组分类：管理员组/普通组<br>&ensp;&ensp;&ensp;&ensp;基本组:Linux中,新建用户时,没有指定隶属于的组,系统会为该用户建立一个同名组,作为该用户基本组<br>&ensp;&ensp;&ensp;&ensp;附加组:方便以后为用户分配文件/程序权限</p><p>process(进程):用户执行应用程序的过程，Ngix用户、MySQL用户，不允许登录到操作系统，只是作为系统用户来运行某个程序。</p><h3 id="etc-passwd解释"><a href="#etc-passwd解释" class="headerlink" title="/etc/passwd解释"></a>/etc/passwd解释</h3><p>用冒号隔开：name:password:UID:GID:GECOS:directory:shell<br>第一列:用户的登录名<br>第二列:加密密码(x表示密码占位符,密码保存在/etc/shadow中)<br>第三列:用户的ID号<br>第四列:组的ID号<br>第五列:用户的描述信息<br>第六列:用户宿主目录<br>第七列:用户默认使用的shell(/etc/shells)</p><h3 id="etc-shadow解释"><a href="#etc-shadow解释" class="headerlink" title="/etc/shadow解释"></a>/etc/shadow解释</h3><p>第一列:用户的登录名<br>第二列:用户加密后的密码<br>第三列:最后一次更改密码时间(从1970年1月1号)<br>第四列:密码最小使用时间<br>第五列:密码最长使用时间</p><h3 id="etc-shadow密码区域解释"><a href="#etc-shadow密码区域解释" class="headerlink" title="/etc/shadow密码区域解释"></a>/etc/shadow密码区域解释</h3><p>(格式:$id$salt$encrypted):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">三部分组成:用$隔开</span><br><span class="line">    第一部分加密算法:</span><br><span class="line">        1:MD5加密</span><br><span class="line">        5:SHA-256加密</span><br><span class="line">        6:SHA-512加密</span><br><span class="line">    第二部分:随机序列号</span><br><span class="line">    第三部分:随机序列号和密码共同加密后的字符串</span><br></pre></td></tr></table></figure></p><p>加密算法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对称加密:加密和解密使用相同的密码(效率高)</span><br><span class="line">非对称加密:加密和解密使用不同的秘钥,公钥和私钥</span><br><span class="line">单向加密,散列加密:提取数据的特征码,常用于数据完整性校验</span><br><span class="line">    1:不可逆</span><br><span class="line">    2:定长输出</span><br><span class="line">        md5: 128位定长输出</span><br><span class="line">        sha: 160位 224位 256 位 384位 512位</span><br><span class="line">    3:雪崩效应:输入数据一小点儿的变化,会引起结果的巨大变化</span><br></pre></td></tr></table></figure></p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/default/useradd</span><br><span class="line"># useradd defaults file</span><br><span class="line">GROUP=100   //可以创建普通组</span><br><span class="line">HOME=/home   //普通用户宿主目录位置(在/home下生成和用户同名的目录,作为用户的宿主目录)</span><br><span class="line">INACTIVE=-1  //是否启用户过期停止使用权,-1代表不启用，如果是2则，是过期后两天停止使用权</span><br><span class="line">EXPIRE=        //设定过期时间,格式为20170501</span><br><span class="line">SHELL=/bin/bash  //设定用户的默认使用shell</span><br><span class="line">SKEL=/etc/skel  //新用户宿主目录模板目录</span><br><span class="line">CREATE_MAIL_SPOOL=yes  //是否为用户启用邮件通知功能 </span><br><span class="line"></span><br><span class="line">SKEL=/etc/skel  //新用户宿主目录模板目录（隐藏文件）：</span><br><span class="line">[root@localhost ~]# ls -a /etc/skel</span><br><span class="line">. .. .bash_logout .bash_profile .bashrc</span><br><span class="line">[root@localhost ~]# ls -a /home/jerry/</span><br><span class="line">. .. .bash_logout .bash_profile .bashrc</span><br></pre></td></tr></table></figure></p><h3 id="etc-skel-目录解释"><a href="#etc-skel-目录解释" class="headerlink" title="etc/skel:目录解释"></a>etc/skel:目录解释</h3><p>(用户宿主目录模板目录,只对新建用户生效)<br>.bash_logout:用户注销时执行的命令<br>.bash_profile:用户登录系统时执行的命令(用户变量)<br>.bashrc:用户登录一个新shell时执行的命令</p><h3 id="etc-login-defs文件解释"><a href="#etc-login-defs文件解释" class="headerlink" title="etc/login.defs文件解释"></a>etc/login.defs文件解释</h3><p>(只对新建用户生效，修改后对以前的用户不会产生影响)<br>MAIL_DIR /var/spool/mail //用户系统邮件存放目录<br>PASS_MAX_DAYS 99999 //密码最长使用期限<br>PASS_MIN_DAYS 0 //最短使用期限,0代表不受限制<br>PASS_MIN_LEN 5 //密码最小长度，5代表5个字符<br>PASS_WARN_AGE 7 //密码过期前的警告时间，<br>UID_MIN 1000 //最小UID号<br>UID_MAX 60000 //最大UID号<br>SYS_UID_MIN 201 //系统用户最小UID<br>SYS_UID_MAX 999 //系统用户最大UID<br>GID_MIN 1000 //普通组最小GID<br>GID_MAX 60000 //普通组最大GID<br>SYS_GID_MIN 201 //系统组最小GID<br>SYS_GID_MAX 999 //系统组最大GID<br>CREATE_HOME yes //是否创建宿主目录<br>UMASK 077 //关于权限反掩码<br>USERGROUPS_ENAB yes //删除用户时是否删除组<br>ENCRYPT_METHOD SHA512 //用户密码的加密方式</p><h2 id="9-用户管理命令"><a href="#9-用户管理命令" class="headerlink" title="9 用户管理命令"></a><strong>9 用户管理命令</strong></h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理:"></a>用户管理:</h3><p>USERADD<br>useradd, userdel, usermod, passwd, chsh, chfn, finger, id, chage<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install vim make cmake man man-pages mlocate sysstat net-tools</span><br><span class="line"># yum -y groupinstall &quot;Development tools&quot;</span><br><span class="line"># mandb //生成whatis数据库</span><br><span class="line"># updatedb //生成locate数据库</span><br><span class="line"># vim /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure></p><h4 id="useradd-添加新用户"><a href="#useradd-添加新用户" class="headerlink" title="useradd:添加新用户"></a>useradd:添加新用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(更改/etc/passwd /etc/shadow /etc/group)</span><br><span class="line">    useradd [options] user_name </span><br><span class="line">    -c:为用户添加描述信息</span><br><span class="line">    -d:指定用户的宿主目录(默认宿主目录在/home目录)</span><br><span class="line">     useradd -d /.../用户名 用户名</span><br><span class="line">    -D:查看和改变默认的值(修改/etc/default/useradd文件中的选项和值)</span><br><span class="line">            -g:修改组</span><br><span class="line">            -b:修改宿主目录</span><br><span class="line">            -f:修改过期是否停用</span><br><span class="line">            -e:修改过期 时间</span><br><span class="line">            -s:修改默认shell</span><br><span class="line">    -e:新建用户时,设置用户默认的过期时间,时间格式为:YYYY-MM-DD</span><br><span class="line">     -g:指定用户的基本组(没有该选项,Linux新建用户时,会新建一个同名组作为用户的基本组)</span><br><span class="line">    -G:新建用户时指定用户的附加组,附加组可以有多个,用逗号隔开</span><br><span class="line">    -m:创建宿主目录,和-k一起使用</span><br><span class="line">    -M:创建用户时,不为用户创建宿主目录</span><br><span class="line">    -p:创建用户时,为用户设置加密的密码(不推荐使用)</span><br><span class="line">    -r:创建系统用户(不创建宿主目录,UID和GID使用系统用户ID)</span><br><span class="line">    -s:指定默认的shell(系统支持的shell)</span><br><span class="line">    -u:指定用户的UID</span><br></pre></td></tr></table></figure><h4 id="passwd-为用户设置密码-锁定解锁用户-查看状态"><a href="#passwd-为用户设置密码-锁定解锁用户-查看状态" class="headerlink" title="passwd:为用户设置密码/锁定解锁用户/查看状态"></a>passwd:为用户设置密码/锁定解锁用户/查看状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">语法:passwd [options] user_name</span><br><span class="line">    root用户可以为普通用户设置密码</span><br><span class="line">    -l:锁定用户(暂时无法登陆系统)</span><br><span class="line">    -u:解锁用户</span><br><span class="line">    -S(大写):查看用户状态,显示/etc/shadow文件中各个字段的内容 （LK、PS）</span><br><span class="line">    --stdin:标准输入,经常用在shell脚本编程中为用户自动设置密码</span><br><span class="line">         如： echo “123” | passwd -- stdin tom（用户名）</span><br><span class="line">    -d:删除用户密码（root用户）,允许普通用户以空密码登录(不建议使用)</span><br><span class="line">    -e:设置用户密码过期,用户再次登录时,需要修改密码</span><br><span class="line">    -n:设置密码最小使用期限,修改/etc/shadow中第四列 </span><br><span class="line">    -x:设置密码最大使用期限,修改/etc/shadow中第五列</span><br><span class="line">    -w:设置密码过期前的警告时间,修改/etc/shadow第六列</span><br><span class="line">    -i:修改过期后的宽限时间,修改/etc/shadow第七列</span><br><span class="line">锁定密码：多了两个感叹号</span><br></pre></td></tr></table></figure><p>普通用户设置密码时,先验证当前密码,符合密码策略<br>root用户设置密码时,不需要验证当前密码,并且也可以不要求符合密码策略</p><h4 id="etc-shadow-保存用户密码相关信息的文件"><a href="#etc-shadow-保存用户密码相关信息的文件" class="headerlink" title="/etc/shadow:保存用户密码相关信息的文件"></a>/etc/shadow:保存用户密码相关信息的文件</h4><p>第一列:用户登录名<br>第二列:加密密码($id$salt$encrypted password)<br>第三列:最后一次更改密码时间<br>第四列:密码最小使用时间(用户无法更改密码)<br>第五列:密码最大使用期限(用户必须更改密码的时间)<br>第六列:密码过期前的警告时间<br>第七列:密码过期后一个宽限时间<br>第八列:密码失效时间<br>第九列:保留 </p><h4 id="userdel-删除用户"><a href="#userdel-删除用户" class="headerlink" title="userdel:删除用户"></a>userdel:删除用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(修改/etc/passwd /etc/shadow /etc/group文件)</span><br><span class="line">语法:userdel [options] user_name</span><br><span class="line">-r:删除用户时,连同删除用户的宿主目录</span><br></pre></td></tr></table></figure><h4 id="usermod-修改用户属性"><a href="#usermod-修改用户属性" class="headerlink" title="usermod:修改用户属性"></a>usermod:修改用户属性</h4><p>(修改/etc/passwd中内容)很多命令与useradd相似<br>语法:usermod [options] user_name<br>-c:更改用户的描述信息<br>-d:更改用户的宿主目录<br>-e:更改用户的过期时间,格式YYYY-MM-DD<br>-f:修改/etc/shadow第七列内容<br>-g:修改用户的基本组<br>-G:修改用户的附加组<br>-l:修改用户的登录名<br>-s:修改用户的shell(系统支持的shell程序)<br>-L(大写):锁定用户<br>-U(大写):解锁用户</p><h4 id="chsh-修改用户的shell"><a href="#chsh-修改用户的shell" class="headerlink" title="chsh:修改用户的shell"></a>chsh:修改用户的shell</h4><p>语法:chsh [options] user_name<br>-s:后面跟shell,更改用户的shell<br>-l:显示当前系统支持的shell(/etc/shells)</p><h4 id="finger-显示用户的基本信息"><a href="#finger-显示用户的基本信息" class="headerlink" title="finger:显示用户的基本信息"></a>finger:显示用户的基本信息</h4><p>finger [options] user_name</p><p>chfn:修改用户的基本信息<br>语法:chfn [options] user_name<br>-o:修改办公室<br>-p:修改办公室电话号码<br>-h:修改家庭电话号码<br>-f:修改用户名</p><p>id:显示用户和组的ID<br>语法:id [options] user_name<br>-a:忽略其他版本区别<br>-Z(大写):显示安全上下文内容(selinux)<br>-g:显示有效组的ID<br>-G:显示所有组的ID<br>-n:不显示组号,显示名字<br>-u:显示用户ID</p><h4 id="chage-修改用户密码的时间信息-etc-shadow"><a href="#chage-修改用户密码的时间信息-etc-shadow" class="headerlink" title="chage:修改用户密码的时间信息(/etc/shadow)"></a>chage:修改用户密码的时间信息(/etc/shadow)</h4><p>语法:chage [options] user_name<br>-l:列出用户的详细的密码参数<br>-d:修改/etc/shadow第三列内容,后面跟日期,格式YYYY-MM-DD<br>-E:修改/etc/shadow第八列内容,后面跟日期,格式YYYY-MM-DD<br>-I:修改/etc/shadow第七列内容,后面跟天数<br>-m:修改/etc/shadow第四列内容,后面跟天数<br>-M:修改/etc/shadow第五列内容,后面跟天数<br>-W:修改/etc/shadow第六列内容,后面跟天数</p><h3 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h3><p><strong>groupadd, groupdel, groupmod, gpasswd,newgrp,groupmems</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/group</span><br><span class="line">root:x:0:</span><br><span class="line">bin:x:1:</span><br><span class="line">daemon:x:2:</span><br></pre></td></tr></table></figure></p><h4 id="etc-group-信息解释"><a href="#etc-group-信息解释" class="headerlink" title="/etc/group:信息解释"></a>/etc/group:信息解释</h4><pre><code>第一列:组的名字第二列:组的密码区域第三列:组的ID号(GID)第四列:组中的成员（初始化成员不显示）</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/gshadow</span><br><span class="line">root:::</span><br><span class="line">bin:::</span><br><span class="line">daemon:::</span><br></pre></td></tr></table></figure><h4 id="etc-gshadow"><a href="#etc-gshadow" class="headerlink" title="/etc/gshadow:"></a>/etc/gshadow:</h4><p>第一列:组的名字<br>第二列:组的密码<br>第三列:组的管理员<br>第四列:组成员列表</p><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><p>-d:创建组时指定组的ID<br>-r:添加一个系统组</p><h4 id="groupdel-删除一个组"><a href="#groupdel-删除一个组" class="headerlink" title="groupdel:删除一个组"></a>groupdel:删除一个组</h4><p>默认情况下,不能删除一个用户的基本组,可以通过修改用户的基本组后删除该组<br>userdel -r 可以删除用户的同时,系统会删除同名基本组(该组是一个用户的基本组) </p><h4 id="groupmod-修改组的属性"><a href="#groupmod-修改组的属性" class="headerlink" title="groupmod:修改组的属性"></a>groupmod:修改组的属性</h4><p>-g:修改组的GID号<br>-n:为组重命名</p><h4 id="gpasswd-为组设置密码-设置组的管理员-添加组成员"><a href="#gpasswd-为组设置密码-设置组的管理员-添加组成员" class="headerlink" title="gpasswd:为组设置密码,设置组的管理员,添加组成员"></a>gpasswd:为组设置密码,设置组的管理员,添加组成员</h4><p>-A:为组设置管理员 Administrator<br>-M:把一些用户添加组中,用逗号隔开(普通用户)<br>-r:为组移除密码<br>-R:让组的密码失效<br>-a:为组添加成员(组的管理员操作命令)<br>-d:删除组成员(组的管理员操作命令)</p><h4 id="newgrp-为用户修改有效组-只在当前shell生效"><a href="#newgrp-为用户修改有效组-只在当前shell生效" class="headerlink" title="newgrp:为用户修改有效组(只在当前shell生效)"></a>newgrp:为用户修改有效组(只在当前shell生效)</h4><p>exit:退出newgrp</p><p>groupmems:为组添加成员,显示组成员列表</p><h2 id="10-Linux权限"><a href="#10-Linux权限" class="headerlink" title="10 Linux权限"></a><strong>10 Linux权限</strong></h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>r(read):读权限,可以查看文件的内容,使用cat more等命令<br>w(write):写权限,可以修改文件的内容及删除文件<br>x(execute):执行权限,可执行文件或脚本</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>r:读权限,可以查看目录中的列表,执行ls命令<br>w:写权限,可以向目录中新建文件或目录等<br>x:执行权限,可以执行cd命令</p><h3 id="权限用数字表示"><a href="#权限用数字表示" class="headerlink" title="权限用数字表示"></a>权限用数字表示</h3><p>r:4<br>w:2<br>x:1<br>—:000 0<br>rwx:111 </p><h3 id="chown-change-owner改变文件属主和属组"><a href="#chown-change-owner改变文件属主和属组" class="headerlink" title="chown:change owner改变文件属主和属组"></a>chown:change owner改变文件属主和属组</h3><pre><code>-R:递归更改目录的属主或属组--reference:复制一个目录的权限属性到目标文件chown:修改文件属组时,在组名前添加点符号(.)或冒号(:)</code></pre><p>同时修改属主和属组:chown username.groupname filename</p><h3 id="chgrp-change-group修改文件属组"><a href="#chgrp-change-group修改文件属组" class="headerlink" title="chgrp:change group修改文件属组"></a>chgrp:change group修改文件属组</h3><h3 id="chmod-修改文件或目录权限"><a href="#chmod-修改文件或目录权限" class="headerlink" title="chmod:修改文件或目录权限"></a>chmod:修改文件或目录权限</h3><p>语法:chmod [augo][+-=][rwx] file_name<br>-R:递归更改文件或目录的权限</p><p>a:所有用户<br>u:文件属主<br>g:文件属组<br>o:其他用户</p><p>+:为用户添加权限<br>-:为用户减少权限<br>=:为用户赋予权限<br>例如：chown a+x  a</p><p>默认情况下,为了安全,Linux系统新建文件时不添加执行权限<br>新建文本文件时候的权限一般为644<br>新建目录时候，执行cd命令：755</p><h3 id="umask-反掩码-在-etc-login-defs中定义"><a href="#umask-反掩码-在-etc-login-defs中定义" class="headerlink" title="umask:反掩码(在/etc/login.defs中定义)"></a>umask:反掩码(在/etc/login.defs中定义)</h3><p>rwx:7<br>文件:rw-rw-rw-:666 644=rw-r–r–<br>目录:rwxrwxrwx:777 755=rwxr-xr-x<br>新建文件时,权限掩码(666)减去反掩码(022)就是新建文件的权限(644)<br>新建目录时,权限掩码(777)减去反掩码(022)就是新建目录的权限(755)<br>掩码发生变化权限也会发生变化</p><h3 id="Linux隐藏权限"><a href="#Linux隐藏权限" class="headerlink" title="Linux隐藏权限"></a>Linux隐藏权限</h3><h4 id="chattr-修改文件的隐藏权限"><a href="#chattr-修改文件的隐藏权限" class="headerlink" title="chattr:修改文件的隐藏权限"></a>chattr:修改文件的隐藏权限</h4><p>/  /dev/  /tmp  /var/  /etc/目录不受chattr保护<br>语法: chattr +-= [options] file_name<br>     a:只能向文件中追加数据,不能删除 Append only<br>chattr +a 文件名，echo “…”&gt;&gt;…文件名<br>      i:任何用户不能删除文件<br>     A:不同步访问时间<br>     +:添加相应权限<br>     -:删除相应权限<br>     =:设定相应权限</p><h4 id="lsattr-查看文件或目录的隐藏权限"><a href="#lsattr-查看文件或目录的隐藏权限" class="headerlink" title="lsattr:查看文件或目录的隐藏权限"></a>lsattr:查看文件或目录的隐藏权限</h4><p>/etc/passwd /etc/shadow /etc/group<br>tom:/etc/passwd /etc/shadow /etc/group添加信息,新建宿主目录(修改宿主目录的归属)<br>echo “tom:x:1001:1001::/home/tom:/bin/bash” &gt;&gt; /etc/passwd<br>使用追加的方法去新建用户：追加passwd和shadow中的用户信息，然后复制模板目录文件；最后修改全部归属的权限。</p><h2 id="11-Linux认证之nsswitch-名词解析）"><a href="#11-Linux认证之nsswitch-名词解析）" class="headerlink" title="11 Linux认证之nsswitch(名词解析）"></a><strong>11 Linux认证之nsswitch(名词解析）</strong></h2><p>认证机制:<br>3A认证:<br>认证机制:authentication(资源申请者证明自己本身的一个过程)<br>授权机制:authorization(用户是否可以访问一个服务或文件,用户访问服务或文件的能力)<br>审计机制:audition</p><p>root a.txt rw-<br>login:user_name:passwd </p><p>vi /etc/nsswitch.conf,该配置文件中规定了名称解析的地址文件顺序，其名词解析库位于lib64中</p><h3 id="什么是nsswithch-conf-服务搜索顺序-文件"><a href="#什么是nsswithch-conf-服务搜索顺序-文件" class="headerlink" title="什么是nsswithch.conf(服务搜索顺序)文件"></a>什么是nsswithch.conf(服务搜索顺序)文件</h3><p>nsswitch.conf(name service switch configuration,名字服务切换配置)文件位于/etc目录下,由它规定通过哪些途径以及按照什么顺序以及通过这些途径来查找特定类型的信息,还可以指定某个方法奏效或失效时系统将采取什么动作。<br>     Nsswitch.conf中的每一行配置都指明了如何搜索信息,每行配置的格式如下:<br>     Info: method[[action]] [method[[action]]…]<br>     其中,info指定该行所描述的信息的类型,method为用来查找该信息的方法,action是对前面的method返回状态的响应。action要放在方括号里。</p><h3 id="nsswitch-conf的工作原理"><a href="#nsswitch-conf的工作原理" class="headerlink" title="nsswitch.conf的工作原理"></a>nsswitch.conf的工作原理</h3><pre><code>当需要提供nsswitch.conf文件所描述的信息的时候,系统将检查含有适当info字段的配置行。它按照从左向右的顺序开始执行配置行中指定的方法。在默认情况下,如果找到期望的信息,系统将停止搜索。如果没有指定action,那么当某个方法未能返回结果时,系统就会尝试下一个动作。有可能搜索结束都没有找到想要的信息。</code></pre><h4 id="信息-Info"><a href="#信息-Info" class="headerlink" title="信息(Info)"></a>信息(Info)</h4><pre><code>Nsswitch.conf文件通常控制着用户(在passwd中)、口令(在shadow中)、主机IP和组信息(在group中)的搜索。下面的列表描述了nsswitch.conf文件控制搜索的大多数信息(Info项)的类型。</code></pre><p>automount:自动挂载(/etc/auto.master和/etc/auto.misc)<br>bootparams:无盘引导选项和其他引导选项(参见bootparam的手册页)<br>ethers:MAC地址<br>group:用户所在组(/etc/group),getgrent()函数使用该文件<br>hosts:主机名和主机号(/etc/hosts),gethostbyname()以及类似的函数使用该文件<br>networks:网络名及网络号(/etc/networks),getnetent()函数使用该文件<br>passwd:用户口令(/etc/passwd),getpwent()函数使用该文件<br>protocols:网络协议(/etc/protocols),getprotoent()函数使用该文件<br>publickey:NIS+及NFS所使用的secure_rpc的公开密钥<br>rpc:远程过程调用名及调用号(/etc/rpc),getrpcbyname()及类似函数使用该文件<br>services:网络服务(/etc/services),getservent()函数使用该文件<br>shadow:映射口令信息(/etc/shadow),getspnam()函数使用该文件<br>aiases:邮件别名,sendmail()函数使用该文件</p><h4 id="方法-method"><a href="#方法-method" class="headerlink" title="方法(method)"></a>方法(method)</h4><p>下面列出了nsswich.conf文件控制搜索信息类型的方法,对于每一种信息类型,都可以指定下面的一种或多种方法:<br>files:搜索本地文件,如/etc/passwd和/etc/hosts<br>nis:搜索NIS数据库,nis还有一个别名,即yp<br>dns:查询DNS(只查询主机)<br>compat:passwd、group和shadow文件中的±语法</p><h4 id="搜索顺序-从左至右"><a href="#搜索顺序-从左至右" class="headerlink" title="搜索顺序(从左至右)"></a>搜索顺序(从左至右)</h4><p>两个或者更多方法所提供的信息可能会重叠。举例来说,files和nis可能都提供同一个用户的口令信息。如果出现信息重叠现象,就需要考虑将哪一种方法作为权威方法(优先考虑),并将该方法放在方法列表中靠左的位置上。<br>默认nsswitch.conf文件列出的方法并没有动作项,并假设没有信息重叠(正常情况)。在这种情况下,搜索顺序无关紧要:当一种方法失败之后,系统就会尝试下一种方法,只是时间上受到一点损失。如果在方法之间设置了动作,或者重叠的项的内容不同,那么搜索顺序就变得重要起来。<br>例如下面两行nsswitch.conf文件配置行:<br>passwd files nis<br>host nis files dns<br>第一行让系统在/etc/passwd文件中搜索口令信息,如果失败的话,就使用NIS来查找信息。如果正在查找的用户同时出现在这两个地方,就会使用本地文件中的信息,因此它就是权威信息。第二行先使用NIS搜索；如果失败的话,就搜索/etc/hosts文件；如果再次失败的话,核对DNS以找出主机信息。</p><h4 id="动作项-action"><a href="#动作项-action" class="headerlink" title="动作项([action])"></a>动作项([action])</h4><p>在每个方法后面都可以选择跟一个动作项,用来指定如果由于某种原因该方法成功抑或失败需要做些什么。动作项的格式如下:<br>[[!]STATUS =action]<br>其中,开头和末尾的方括号属于格式的一部分,并不是用来指出括号中的内容是可选的。STATUS(按照约定使用大写字母,但本身并不区分大小写)是待测试的状态,action是如果STATUS匹配前面的方法所返回的状态将要执行的动作。开头的感叹号(!)是可选的,其作用是将状态取反。<br>STATUS的取值如下:<br>NOTFOUND:方法已经执行,但是并没有找到待搜索的值。 默认的动作是continue。<br>SUCCESS:方法已经执行,并且已经找到待搜索的值,没有返回错误。默认动作是return。<br>UNAVAIL:方法失败,原因是永久不可用。举例来说,所需的文件不可访问或者所需的服务器可能停机。默认的动作是continue。<br>TRYAGAIN:方法失败,原因是临时不可用。举例来说,某个文件被锁定,或者某台服务器超载。默认动作是continue。<br>action的取值如下:<br>return:返回到调用例程,带有返回值,或者不带返回值。<br>continue:继续执行下一个方法。任何返回值都会被下一个方法找到的值覆盖。<br>示例:<br>举例来说,下面这行取自nsswitch.conf文件,它的作用是让系统首先使用DNS来搜索给定主机的IP地址。DNS方法后面的动作项是测试该方法所返回的状态是否为“非(!)UNAVAIL”。<br>hosts dns [!UNAVAIL=return] files<br>如果DNS方法没有返回UNAVAIL(!UNAVAIL),也就是说DNS返回SUCCESS、NOTFOUND或者TRYAGAIN,那么系统就会执行与该STATUS相关的动作(return)。其结果就是,只有在DNS服务器不可用的情况下才会使用后面的方法(files)。<br>如果DNS服务器并不是不可用(两次否定之后就是“可用”),那么搜索返回域名或者报告未找到域名。只有当服务器不可用的时候,搜索才会使用files方法(检查本地的/etc/hosts文件)。</p><h4 id="compat方法-passwd、group和shadow文件中的”±”"><a href="#compat方法-passwd、group和shadow文件中的”±”" class="headerlink" title="compat方法:passwd、group和shadow文件中的”±”"></a>compat方法:passwd、group和shadow文件中的”±”</h4><p>可以在/etc/passwd、/etc/group和/etc/shadow文件中放入一些特殊的代码,(如果在nsswitch.conf文件中指定compat方法的话)让系统将本地文件和NIS映射表中的项进行合并和修改。<br>在这些文件中,如果在行首出现加号’＋’,就表示添加NIS信息；如果出现减号’－’,就表示删除信息。举例来说,要想使用passwd文件中的这些代码,可以在nsswitch.conf文件中指定passwd: compat。然后系统就会按照顺序搜寻passwd文件,当它遇到以+或者 开头的行时,就会添加或者删除适当的NIS项。<br>虽然可以在passwd文件的末尾放置加号,在nsswitch.conf文件中指定passwd: compat,以搜索本地的passwd文件,然后再搜寻NIS映射表,但是更高效的一种方法是在nsswitch.conf文件中添加passwd: file nis而不修改passwd文件。</p><h2 id="12-Linux认证之PAM"><a href="#12-Linux认证之PAM" class="headerlink" title="12 Linux认证之PAM"></a><strong>12 Linux认证之PAM</strong></h2><h3 id="12-1-PAM的Login模块"><a href="#12-1-PAM的Login模块" class="headerlink" title="12.1 PAM的Login模块"></a>12.1 PAM的Login模块</h3><p>login（登陆过程，先解析后验证）:<br>①root–nsswitch.conf–passwd: files<br>②123–nsswitch.conf–shadow: files<br>③authentication:123–sha512(salt)–/etc/shadow compare<br>①和②由nsswitch到passwd和shadow中去查找，第三步交由PAM来处理，直接验证<br>nsswitch：files db nis ldap<br>authentication：files db nis ldap kerberos等</p><p>ldd:查看某个服务所支持的模块<br>语法:ldd service_path，与当前目录无关</p><p>authentication：当某个应用程序需要验证的时候，会需要一个中间的模块进行辅助验证，该模块即为PAM<br>PAM：嵌入式认证模块，PAM本身不会执行验证，需要借助一系列策略或模块来验证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost security]# ldd /usr/sbin/httpd | grep libpam </span><br><span class="line">[root@localhost security]# cd /etc/pam.d/</span><br><span class="line">在这个目录下的文件包含了验证信息，如果有标识的文件找不到的话，就会到other目录中去寻找认证。</span><br><span class="line">[root@localhost pam.d]# cat vsftpd</span><br><span class="line">[root@localhost pam.d]# cat other</span><br></pre></td></tr></table></figure></p><p>即：<br>/etc/pam.d/service_name(系统中支持pam认证的服务名称)<br>/etc/pam.d/other(当系统中支持pam认证的服务没有匹配到任何条目时,匹配other中的配置)</p><p>/etc/pam.d/service_name格式，<br>其文件内容<br>每一列表示的内容分别为<br>type类型  control控制标准 modules模块 [modules_args]模块的参数选项，可省略</p><h4 id="type类型"><a href="#type类型" class="headerlink" title="type类型"></a>type类型</h4><p>auth(entication):身份验证,匹配用户名和密码<br>account:检查用户名和密码的有效性<br>password:检查修改改密码时,密码是否符合标准<br>session:检查用户会话相关属性</p><h4 id="control"><a href="#control" class="headerlink" title="control"></a>control</h4><p>required:一票否决权,继续匹配下面的条目,最后不匹配(保护系统的安全性)<br>requisite:一票否决权,不匹配下面的条目,直接给用户返回结果<br>sufficient:一票同意权,不匹配下面的条目,直接给用户返回结果(慎用)<br>optional:不影响最终结果<br>include:引用其他的配置文件,把匹配权交给其他配置文件(如果其他配置跳出,则整个匹配结束)<br>substack:引用其他的配置,把匹配权交给其他配置文件(如果其他配置跳出,则仅仅跳出子匹配)</p><h4 id="modules-匹配认证模块"><a href="#modules-匹配认证模块" class="headerlink" title="modules:匹配认证模块"></a>modules:匹配认证模块</h4><p>另外还有一种比较复杂的格式为value = action的语法来设置控制标志,标志之间会以空格分开.格式如下:<br><code>value1 = action1 value2 = action2 ……</code><br>     其中value可以是下列Linux PAM库的返回值:<br>success、open_err、symbol_err、service_err、 system_err、buf_err、perm_denied、auth_err、cred_insufficient、authinfo_unavail、user_unknown、maxtries、new_authtok_reqd、acct_expired、 session_err、cred_unavail、cred_expired、cred_err、no_module_data、conv_err、 authtok_err、authtok_recover_err、authtok_lock_busy、authtok_disable_aging、 try_again、ignore、abort、authtok_expired、module_unknown、bad_item和default.<br>最后一个(default)能够用来设置上面的返回值无法表达的行为.</p><p>required [success=ok new_authtok_reqd=ok ignore=ignore default=bad]<br>requisite [success=ok new_authtok_reqd=ok ignore=ignore default=die]<br>sufficient [success=done new_authtok_reqd=done default=ignore]<br>optional [success=ok new_authtok_reqd=ok default=ignore] </p><h4 id="action值"><a href="#action值" class="headerlink" title="action值"></a>action值</h4><pre><code>ignore:忽略执行结果bad:如果失败,结果被用于整个执行栈,后续栈继续执行die:和bad相似,但是失败直接返回结果,后续栈不执行ok:如果PAM_SUCCESS覆盖之前值done:和ok 相似,但是栈直接返回结果 reset:重置栈当前状态</code></pre><h3 id="12-2-PAM的modules-认证模块"><a href="#12-2-PAM的modules-认证模块" class="headerlink" title="12.2 PAM的modules 认证模块"></a>12.2 PAM的modules 认证模块</h3><p>/etc/pam.d/<em>:每一个应用程序PAM配置文件<br>PAM模块真正存放的位置<br>/usr/lib64/security/</em>:PAM认证模块文件的实际存放位置<br>/etc/security/*:其他PAM环境的配置文件,比如 access.conf<br>/usr/share/doc/pam-x:存放详细的PAM的说明文件</p><p>反撇号直接引用命令结果</p><h4 id="modules-PAM认证模块"><a href="#modules-PAM认证模块" class="headerlink" title="modules:PAM认证模块"></a>modules:PAM认证模块</h4><p>/etc/pam.d/<em>:每一个应用程序PAM配置文件<br>/usr/lib64/security/</em>:PAM认证模块文件的实际存放位置<br>/etc/security/*:其他PAM环境的配置文件,比如 access.conf<br>/usr/share/doc/pam-x:存放详细的PAM的说明文件</p><p>查看应用程序是否支持PAM认证<br>ldd app_path<br>如: ldd /usr/sbin/vsftpd | grep libpam</p><p>pam_env.so:设置环境变量的模块,如果需要额外的环境变量,可以使用pam_env.so进行设置,配置文件/etc/security/pam_env.conf </p><p>pam_unix.so:提供验证阶段的验证功能,也可以提供授权管理<br>pam_secruetty.so:限制系统管理员只能够从安全的终端登录,安全终端:/etc/securetty<br>pam_nologin.so:限制普通使用者能否登录主机进行使用,当/etc/nologin文件存在时,所有的普通用户都无法登录<br>pam_cracklib.so:可是限制恶意攻击,检查密码强度<br>pam_pwquality.so:完全兼容pam_cracklib.so,检查密码强度,包括设置的密码是否在字典<br>pam_limits.so:限制使用者打开文件数量,单个文件大小等<br>pam_rootok.so:如果UID为0,直接通过,如root用户su到普通用户使用此模块<br>pam_listfile.so:验证使用其他的文件<br>pam_access.so:控制访问的模块,默认配置/etc/security/access.conf</p><ul><li>: ALL EXCEPT gooann:ALL</li></ul><h4 id="ulimit-语法"><a href="#ulimit-语法" class="headerlink" title="ulimit:语法"></a>ulimit:语法</h4><p> ulimit [options] 限额<br>options:<br>-H:hard limit:严格的限制,必须不能超过这个设置的数值<br>-S:soft limit:警告的限制,超过这个数值系统会发出警告,通常soft比hard小<br>-a:后面不加任何选项,可以列出系统中所有的限制额度<br>-c:当某个用户程序发生错误的时候,系统会将内存中的应用程序写成文件,这种文件成为核心文件(core file),限制每个核心文件的最大容量<br>-f:此shell可以创建的文件的大小,单位kb<br>-l:可以锁定的内存量<br>-u:单一用户可以使用的最大的进程量<br>-t:可以使用的最大的CPU时间</p><h4 id="limits配置文件"><a href="#limits配置文件" class="headerlink" title="limits配置文件"></a>limits配置文件</h4><p>/etc/security/limits.conf<br>配置文件格式</p><p><domain> <type> <item> <value><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">domain:可以是用户,组或*,*代表所有限制</span><br><span class="line">type:soft(软限制) hard(硬限制)</span><br><span class="line">item:</span><br><span class="line">- core - limits the core file size (KB)</span><br><span class="line">- data - max data size (KB)</span><br><span class="line">- fsize - maximum filesize (KB)</span><br><span class="line">- memlock - max locked-in-memory address space (KB)</span><br><span class="line">- nofile - max number of open file descriptors</span><br><span class="line">- rss - max resident set size (KB)</span><br><span class="line">- stack - max stack size (KB)</span><br><span class="line">- cpu - max CPU time (MIN)</span><br><span class="line">- nproc - max number of processes</span><br><span class="line">- as - address space limit (KB)</span><br><span class="line">- maxlogins - max number of logins for this user</span><br><span class="line">- maxsyslogins - max number of logins on the system</span><br><span class="line">- priority - the priority to run user process with</span><br><span class="line">- locks - max number of file locks the user can hold</span><br><span class="line">- sigpending - max number of pending signals</span><br><span class="line">- msgqueue - max memory used by POSIX message queues (bytes)</span><br><span class="line">- nice - max nice priority allowed to raise to values: [-20, 19]</span><br></pre></td></tr></table></figure></value></item></type></domain></p><p>value:限制的具体数值</p><p>试验:使用pam认证模块限制sshd登录用户(pam_listfile.so)</p><p>只允许root和gooann组的用户可以登录</p><p>locate find tar gzip bzip tree stat install du df uname less more date clock hwclock</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-虚拟机的使用&quot;&gt;&lt;a href=&quot;#1-虚拟机的使用&quot; class=&quot;headerlink&quot; title=&quot;1 虚拟机的使用&quot;&gt;&lt;/a&gt;&lt;strong&gt;1 虚拟机的使用&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;创建虚拟机&lt;br&gt;磁盘：虚拟机中文件形式存在（镜像文件）&lt;
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git分布式版本控制系统</title>
    <link href="http://yoursite.com/2017/07/11/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/07/11/Git分布式版本控制系统/</id>
    <published>2017-07-11T03:27:20.000Z</published>
    <updated>2018-09-18T17:24:25.450Z</updated>
    
    <content type="html"><![CDATA[<p>用途：多人在线协作，记录文件中的每次改动的时间和内容。<br>Git的诞生：BitMover公司的BitKeeper为Linux的免费使用权的收回。使得Linus自己去开发了一个版本控制系统即Git。</p><h2 id="版本控制系统类型"><a href="#版本控制系统类型" class="headerlink" title="版本控制系统类型"></a>版本控制系统类型</h2><p>集中式：版本库是集中存放在中央服务器的，个人每次使用时，都必须从中央调用出来，然后改完后再放回中央。<br>缺点即需要联网。网速可能会影响协作效率。<br>而分布式：人人都有版本库。无需联网。这样对于同一份文件，每个人自己修改完之后，就可以存储在本地当中，随时可以修改，并且如果多人协作查看修改，则相互之间互推修改版本就可看到对方修改的内容。分布式也可以有一台充当“ 中央服务器 ”的电脑。这样方便“交换”大家的修改。修改的内容会覆盖上去。可以每个人负责不同的版块，然后拼接成一个完整的文件。然后还有所谓主次之分，即所有的修改需要经过主负责审核，才能通过与覆盖。<br>     并且分布式相较于集中式安全，就是由于人人有版本库，就不担心其中一台电脑出事后，所有数据都丢失了。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><h3 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h3><p>1.输入Git查看系统是否安装git：$ git<br>2.根据返回的信息协作，安装。<br>（Debian或Ubuntu Linux）键入下值即可安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p><pre><code>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入： ./config，make，sudo make install 这几个命令安装就好了。</code></pre><h3 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h3><p>两种安装方法：<br>1.安装homebrew（软件包管理器），通过它安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/" target="_blank" rel="noopener">http://brew.sh/</a><br>2.AppStore安装Xcode。运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”。</p><h3 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h3><p>Windows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，从<a href="https://git-for-windows.github.io下载（国内镜像网站https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit）" target="_blank" rel="noopener">https://git-for-windows.github.io下载（国内镜像网站https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit）</a></p><h2 id="版本库Repository，又名“仓库”"><a href="#版本库Repository，又名“仓库”" class="headerlink" title="版本库Repository，又名“仓库”"></a>版本库Repository，又名“仓库”</h2><p>可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit # 创建目录</span><br><span class="line">$ cd learngit # 进入目录learngit</span><br><span class="line">$ pwd #显示目录路径</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git init  #将目录初始化为git</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br><span class="line">$ ls # 可以查看当前列表是否已经建立版本库</span><br><span class="line">learngit</span><br><span class="line">$ ls -ah #查看隐藏目录</span><br><span class="line">.          .bash_history     .gitconfig</span><br><span class="line">..         .git              learngit</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt #learngit目录下新建readme.txt，然后将新建的文件夹加入到缓存区stage（或index）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;  #将文件提交到master区间</span><br><span class="line">[master (root-commit) cb926e7] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log #查看修改的详细过程</span><br><span class="line">commit 3628164fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 15:11:49 2013 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>如果觉得git log命令太多可以使用下面的这个命令，这两个可以查看自己修改过的版本，然后利用commit id进行版本回退或者前进<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git log --pretty=oneline #省略不必要的信息</span><br><span class="line">3628164fb26d48395383f8f31179f24e0882e1e0 append GPL</span><br><span class="line">ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed</span><br><span class="line">cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file</span><br></pre></td></tr></table></figure></p><p>版本回退</p><p>在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git reset --hard HEAD^ #回到上一个版本</span><br><span class="line">HEAD is now at ea34578 add distributed</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt #使用cat可以查看是否回退到上一个版本</span><br></pre></td></tr></table></figure><p>再次利用git log可以查看历史版本，就会发现刚刚的版本不见了，如果又想回去回到“未来”的状态，那么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog #这个命令记录了每一次命令的过程ID，查到后再用reset就可回到未来。</span><br><span class="line">ea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">3628164 HEAD@&#123;1&#125;: commit: append GPL</span><br><span class="line">ea34578 HEAD@&#123;2&#125;: commit: add distributed</span><br><span class="line">cb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure></p><p>而采用git status 可以查看状态（该图与上图无关联）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status #查看版本修改的确定态</span><br><span class="line"># On branch master</span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure></p><p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。下面的例子可以说明对修改过程的控制：<br>对版本库中主分支的 readme.txt 进行.第一次修改后 git add –&gt;添加到了暂存区，如果这个时候再对 readme.txt 进行二次修改 但却没有git add 到缓存区，那么进行 git commit–&gt;提交到master中 是第一次修改后的内容，第二次的修改是无效的。<br>[x]第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit<br>[]第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt</span><br></pre></td></tr></table></figure></p><p><strong>使用这个命令可以查看工作区和版本库里最新版本的区别，以分辨提交的是第几次修改的内容</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt #使用cat命令可以查看txt文本的内容</span><br></pre></td></tr></table></figure></p><h2 id="后悔药"><a href="#后悔药" class="headerlink" title="后悔药"></a>后悔药</h2><p>1.如果在工作区的文件输入错误但未添加到暂缓区域，可使用 git checkout – file 丢弃修改。<br>[x]如果缓存区中原有该文件，则回退到缓存区的文件状态。<br>[x]如果没有，则是回退到版本库master中的文件状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure></p><p>2.若错误内容已添加git add到了暂缓区域，但未 commit。可使用reset 命令回到到工作区。 git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       readme.txt</span><br></pre></td></tr></table></figure></p><p>3.不仅 git add –&gt;缓存区，而且还 git commit–&gt;到版本库了…<br>还好还好，还没推到远程仓库。使用上面说过的 版本回退 就可以回到初始状态啦，不虚不虚</p><p>4.删除文件：<code>git rm file</code>，删错可使用于  <code>git checkout --</code> 一键还原</p><h2 id="远程仓库Github"><a href="#远程仓库Github" class="headerlink" title="远程仓库Github"></a>远程仓库Github</h2><p>（先在Github中配置所需要的步骤SSH keygen）<br>1.关联远程仓库。<br>远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:Github账户名/learngit.git</span><br><span class="line">git remote add origin git@server-name:path/repo-name.git</span><br></pre></td></tr></table></figure></p><p>2.把本地库的所有内容推送到远程库上<br>     把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure></p><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>Git鼓励大量使用分支：<br>查看分支：<code>git branch</code><br>创建分支：<code>git branch &lt;name&gt;</code><br>切换分支：<code>git checkout &lt;name&gt;</code><br>创建+切换分支：<code>git checkout -b &lt;name&gt;</code><br>合并某分支到当前分支：<code>git merge &lt;name&gt;</code><br>删除分支：<code>git branch -d &lt;name&gt;</code></p><p>解决冲突：<br>[]本地分支冲突， 解决完冲突再提交即可。<br>[]远程仓库，多人协作冲突。推送到远程库中出现冲突那么要使用下拉，先冲远程拉下文件，在本地解决完冲突再提交即可。但在下拉前要注意 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name<br>再使用 git pull ，后续与本地分支冲突处理方法类似。</p><h3 id="标签管理Tag"><a href="#标签管理Tag" class="headerlink" title="标签管理Tag"></a>标签管理Tag</h3><p>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。<br>1.给分支打标签：在分支所在目录下 运行  git tag <name>  即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git tag #再用这个即可查看所有标签名</span><br></pre></td></tr></table></figure></name></p><p>2.给 commit Id 打标签：如果commit id是6224937，则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git tag v0.9 6224937</span><br></pre></td></tr></table></figure></p><p>先用git tag 查看了所有标签后， 用 git show <tagname> 可查看对应标签的详细信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git show v0.9</span><br><span class="line">commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 11:22:08 2013 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br></pre></td></tr></table></figure></tagname></p><p>3.标签打错了，也可以删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令git push origin &lt;tagname&gt;可以推送一个本地标签；</span><br><span class="line">命令git push origin --tags可以推送全部未推送过的本地标签；</span><br><span class="line">命令git tag -d &lt;tagname&gt;可以删除一个本地标签；</span><br><span class="line">命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。</span><br></pre></td></tr></table></figure></p><p><code>$ git tag -d 标签</code></p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>利用<code>$ git config --global alias.</code>别名 原命令名  ” 就可以给复杂的命令配置别名<br><code>$ git config --global alias.st status</code><br>后面的就不写啦啦啦，详细的教程都在廖雪峰的网站上面有。<br> <a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用途：多人在线协作，记录文件中的每次改动的时间和内容。&lt;br&gt;Git的诞生：BitMover公司的BitKeeper为Linux的免费使用权的收回。使得Linus自己去开发了一个版本控制系统即Git。&lt;/p&gt;
&lt;h2 id=&quot;版本控制系统类型&quot;&gt;&lt;a href=&quot;#版本控制
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>“淘宝技术这十年”</title>
    <link href="http://yoursite.com/2017/07/11/%E2%80%9C%E6%B7%98%E5%AE%9D%E6%8A%80%E6%9C%AF%E8%BF%99%E5%8D%81%E5%B9%B4%E2%80%9D/"/>
    <id>http://yoursite.com/2017/07/11/“淘宝技术这十年”/</id>
    <published>2017-07-11T03:27:20.000Z</published>
    <updated>2018-09-18T17:26:40.522Z</updated>
    
    <content type="html"><![CDATA[<p>“少时淘气，大时淘宝”<br><img src="https://app.yinxiang.com/shard/s16/res/ec443bd4-e611-4a03-841f-333d83192889/A9@LTY%5DQG_81BG%7DJB5FMPD.png" alt="思维导图"> </p><h2 id="时势造英雄"><a href="#时势造英雄" class="headerlink" title="时势造英雄"></a>时势造英雄</h2><p><code>起因</code><br>eBay 易趣 在资本方面对仗，阿里想趁此崛起新项目<br>就要求能在短时间内做出一个 <strong>个人对个人的商品交易网站</strong>（C2C）<br>2003年4月7日-5月10日 一个月 淘宝技术团队采取购买方案</p><p><code>需求分析</code><br>自建|购入<br>:-:|:-<br>时间成本高，故不采用|要求比较低的维护成本；方便扩展和二次开发；轻量、简单</p><p><strong><code>LAMP Linux+Apache+MySQL+PHP</code></strong><br>优点：无须编译，发布快速；PHP语言功能强大，能做到从页面渲染到数据访问所有的事情，且用到的技术都是开源免费的</p><p>提供淘宝网站系统的官网：<a href="http://auctionphp.com/" target="_blank" rel="noopener">PHPAuction</a></p><p><code>购入后修改</code><br>增加后台管理功能、修改页面模板、页眉页脚加上自己站点简介；<br>数据库拆分：拆分成一个主库+连个从库，并且读写分离</p><p><code>数据库拆分优点</code><br>存储容量增加；备份提高数据安全性；读写分离提升读写效率</p><center><strong>淘宝网”个人网站”即横空出世了</strong><br><br><img src="http://image20.it168.com/201202_500x375/956/1b32939e614a3ac1.png" alt="系统架构第一版"><br>  </center><p> 这个第一版系统中包含商品发布、管理、搜索、商品详情、出价购买、评价投诉、我的淘宝等功能<br> <code>系统改进</code><br> 背景：用户需求、流量增长、数据库资源增大<br> 服务器：由一台变成了三台 <strong>Email + 运行数据库 + 运行WebApp</strong><br> 数据库搜索： <strong>like → isearch</strong></p><p> <code>问题短板</code><br> 访问量和数据量的飞涨，数据库的性能缺陷突出：<br> 1 当Master同步数据到Slave时，会引起Slave写，此时的Slave读操作都需要等待。<br> 2 同时会发生Slave的主键冲突，经常导致同步停止，使得查询失败。</p><h2 id="打怪升级"><a href="#打怪升级" class="headerlink" title="打怪升级"></a>打怪升级</h2><p>在前述的问题短板的情况下，阿里必须提出技术解决方案：</p><center>把MySQL换成Oracle<br><img src="http://static.oschina.net/uploads/img/201411/13161406_GK8j.jpg" alt="此处输入图片的描述"></center><p><code>Oracle</code><br>优点：<strong>容量大、稳定、安全、性能高</strong><br>人才条件：阿里有顶尖团队</p><h3 id="更换数据库"><a href="#更换数据库" class="headerlink" title="更换数据库"></a>更换数据库</h3><p>访问方式 + SQL语法 + <strong>连接池设计</strong>（关键）</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p><code>连接池</code><br>连接池中放的是长连接，是进程级别的，在创建进程的时候，要独占一分部分内存空间，这部分连接数在固定内存的Oracle server上是有限的，任何一个请求只需要从连接池中取得一个连接即可，用完后释放，不需要频发地创建和断开连接，要知道连接的创建与断开开销是非常大的。<br><code>PHP语言</code><br>对数据库的访问很直接，每一个请求都需要一个连接。如果是长连接，应用故武器增多时，连接数就多了，就会把数据库拖挂；而如果是短连接，频繁得连接再断开 数据库性能会非常差</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>开源的连接池代理服务  <a href="http://sqlrelay.sourceforge.net/" target="_blank" rel="noopener">SQL Relay</a></p><h4 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h4><p>SQL Relay死锁 只能靠重启服务解决</p><h3 id="存储扩容"><a href="#存储扩容" class="headerlink" title="存储扩容"></a>存储扩容</h3><p><em>NAS 数据库存储设备（Network Appliance）+ Oracle RAC（Real Application Clusters，实时应用集群）实现负载均衡</em><br><code>NAS的NFS文件系统协议传输延迟很严重</code>↓<br>改用了Dell和EMC合作的SAN低端存储<br><code>数据量的增大→存储结点的不断拆分</code>↓RAC出现问题<br>购买小型机</p><h3 id="支付手段创新-支付宝"><a href="#支付手段创新-支付宝" class="headerlink" title="支付手段创新-支付宝"></a>支付手段创新-支付宝</h3><p>安全交易、第三方托管、开发与银行网关对接功能</p><h3 id="交流方式创新-淘宝旺旺"><a href="#交流方式创新-淘宝旺旺" class="headerlink" title="交流方式创新-淘宝旺旺"></a>交流方式创新-淘宝旺旺</h3><h2 id="脱胎换骨-边换边跑"><a href="#脱胎换骨-边换边跑" class="headerlink" title="脱胎换骨 边换边跑"></a>脱胎换骨 边换边跑</h2><p>“好的架构图充满美感”。第二幅架构图显得头重脚轻，不是个稳定的版本，打怪的时候还是留下了祸根，SQL relay的问题无法解决，数据库必须使用oracle。</p><h3 id="换开发语言-PHP-→-JAVA"><a href="#换开发语言-PHP-→-JAVA" class="headerlink" title="换开发语言 PHP → JAVA"></a><strong>换开发语言 PHP → JAVA</strong></h3><p><code>JAVA</code><br>成熟的网站开发语言 比较良好的企业开发框架 开发经验人才多 后续维护成本比较低 有很多现成的连接池<br><code>Sun公司</code><br>创建java语言的开发公司，eBay的网站也经历过从C++到java的类似开发语言换骨，也是由Sun公司完成的。淘宝也请了Sun公司为淘宝主刀</p><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>迁移过程中不停止服务，原系统的bugfix和功能改进不受影响。</p><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><p>给业务分模块，一个一个模块地渐进式替换。如用户模块，老的<code>member.taobao.com</code>继续维护，不添加新功能，新的功能先在新的模块上开发，跟老的共用一个数据库，开发完毕之后放到不同的应用集群上，另开个域名 <code>member1.taobao.com</code>，同时替换老的功能，替换一个，把老的模块上的功能关闭一个，逐渐的把用户引导到 <code>member1.taobao.com</code>，等所有功能都替换完毕之后，关闭 <code>member.taobao.com</code>。</p><p><code>小问题</code><br>二级域名<code>member1.taobao.com</code>应该是个过度状态，但却很难把member1切换回member，因为有些地方连接已经写死了</p><h3 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h3><p><code>Java MVC</code> <code>struts1.x</code><br>在多人协作方面有很多致命弱点，没有轻量框架作为基础，很难扩展<br><code>WebX</code><br>阿里巴巴 周悦虹 在 JAkarta Turbine 的基础上做了很多扩展 打造了一个阿里巴巴自己用的MVC框架 WebX。该框架易于扩展 方便组件化开发，页面模板支持 JSP 和 Velocity ，持久层支持ibatis 和 hibernate 等，控制层可以用EJB和Spring</p><center><img src="https://img-blog.csdn.net/20160518094106559?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="JAVA 脱胎换骨"></center><h3 id="性能-容量-成本的进化"><a href="#性能-容量-成本的进化" class="headerlink" title="性能 容量 成本的进化"></a>性能 容量 成本的进化</h3><p><code>数据库扩展</code><br>Oracle “分库分表”：把用户的信息按照ID来存放到两个数据库汇总DB1DB2，把商品信息和卖家信息放在两个对应的数据库里面，把商品类目等通用信息放在第三个库里面(DBcommon)。这么做的目的除了增加了数据库的容量之外，还有一个就是做容灾，万一一个数据库挂了，整个网站上还有一半的数据能操作。　　<br><code>数据的合并、排序、分页</code><br>DBRoute，统一数据的合并、排序、分页，该框架一直延续在Oracle时段。<br><code>Spring</code><br>EJB → Spring 系统精简了代码<br><code>缓存 CDN（内容分发网络）</code><br>缓存初型：Berkeley DB缓存系统，该缓存系统性能比较弱，存放不太变动的只读信息。<br>CDN 起初采用China Cache 后改用自己开发的CDN</p><center>脱胎换骨架构图<br><img src="https://static.oschina.net/uploads/img/201411/13161406_c8yZ.jpg" alt="此处输入图片的描述"></center><p>去IOE （IBM小型机 Oracle EMC存储）</p><h2 id="创新技术"><a href="#创新技术" class="headerlink" title="创新技术"></a>创新技术</h2><p>“用钱能解决的问题 都不是问题” 业务推动创新 创新推动业务</p><h3 id="淘宝文件系统TFS"><a href="#淘宝文件系统TFS" class="headerlink" title="淘宝文件系统TFS"></a>淘宝文件系统TFS</h3><p><code>商用存储系统的局限</code><br>1 没有对小文件存储和读取环境进行针对性优化<br>2 文件数量大 网络存储设备无法支撑<br>3 系统所连接服务器越来越多<br>4  商用存储系统扩容成本高，存在单点故障，容灾和安全性无法得到保障</p><p><code>商用系统和自主研发之间的经济效益对比</code><br>1 商用软件很难满足大规模系统的应用需求，无论存储还是CDN还是负载均衡，因为在厂商实验室端，很难实现如此大的数据规模测试。<br>2 研发过程中，将开源和自主开发相结合，会有更好的可控性，系统出问题了，完全可以从底层解决问题，系统扩展性也更高。<br>3 在一定规模效应基础上，研发的投入都是值得的。上图是一个自主研发和购买商用系统的投入产出比对比，实际上，在上图的交叉点左边，购买商用系统都是更加实际和经济性更好的选择，只有在规模超过交叉点的情况下，自主研发才能收到较好的经济效果。实际上，规模化达到如此程度的公司其实并不多，不过淘宝网已经远远超过了交叉点。</p><center><img src="https://img-blog.csdn.net/20160518094302120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="投入与规模关系图"></center><p><code>TFS存储需求</code><br>　   文件比较小；并发量高；读操作远大于写操作；访问随机；没有文件修改的操作；要求存储成本低；能容灾能备份。应对这种需求，显然要用分布式存储系统；由于文件大小比较统一，可以采用专有文件系统；并发量高，读写随机性强，需要更少的 IO 操作；考虑到成本和备份，需要用廉价的存储设备；考虑到容灾，需要能平滑扩容。<br>　   参照GFS 产生的TFSv1.0：<br>　   <img src="https://img-blog.csdn.net/20160518094330761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="TFS 1.0"><br>　<br>4 自主研发的系统可在软件和硬件多个层次不断的优化。</p><blockquote><p>在这个架构中：<br>　　• 每个 Data Server 运行在一台普通的 Linux 主机上<br>　　• 以 block 文件的形式存放数据文件(一般64M一个block )<br>　　• block 存多份保证数据安全<br>　　• 利用 ext3 文件系统存放数据文件<br>　　• 磁盘 raid5 做数据冗余<br>　　• 文件名内置元数据信息，用户自己保存TFS文件名与实际文件的对照关系 – 使得元数据量特别小。</p></blockquote><pre><code>淘宝 TFS 文件系统在核心设计上最大的取巧的地方就在，传统的集群系统里面元数据只有1份，通常由管理节点来管理，因而很容易成为瓶颈。而对于淘宝网的用户来说，图片文件究竟用什么名字来保存实际上用户并不关心，因此TFS在设计规划上考虑在图片的保存文件名上暗藏了一些元数据信息，例如图片的大小、时间、访问频次等等信息，包括所在的逻辑块号。而在元数据上，实际上保存的信息很少，因此元数据结构非常简单。仅仅只需要一个fileID，能够准确定位文件在什么地方。由于大量的文件信息都隐藏在文件名中，整个系统完全抛弃了传统的目录树结构，因为目录树开销最大。拿掉后，整个集群的高可扩展性极大提高。实际上，这一设计理念和目前业界的“对象存储”较为类似，淘宝网 TFS 文件系统已经更新到 1.3 版本，</code></pre><p><code>TFS1.3重点改善</code><br>心跳和同步性能、元数据存储在内存中，清理磁盘空间等<br>性能优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">采用ext4文件系统 并且预分配文件 减少ext3等文件系统数据碎片带来的性能损耗；</span><br><span class="line">单进程管理单块磁盘的方式，摒除RAID5机制</span><br><span class="line">带有HA机制的重要控制节点，在安全稳定和性能复制度之间取得平衡</span><br><span class="line">缩减元数据大小，将更多的元数据加载如内存，提升访问速度</span><br><span class="line">跨级计啊和IDC负载均衡及冗余安全策略</span><br><span class="line">完全平滑扩容</span><br></pre></td></tr></table></figure></p><p><code>图片文件服务器</code><br>部署在TFS前端，用Apache实现，缩略图实时生成<br>1 避免后端图片服务器上存储的图片数量过多，大大节约了后台存储空间的需求<br>2 缩略图可实时生成，更加灵活<br>3 采用一级缓存和二级缓存，前面还有全局负载均衡的设置</p><blockquote><p>淘宝网缓存策略：淘宝网在各个运营商中心点设有二级缓存，整体系统中心店设有一级缓存，加上全局负载均衡，传递到后端的TFS流量就已经非常均衡和分散了，对前端的响应性能也大大提升。淘宝大部分图片都尽量在缓存中命中，如果无法命中，则在本地服务器上查找手否存有原图，并根据原图生产缩略图，如果都没有命中，则考虑去后台TFS集群文件存储系统上调取。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op1=&gt;operation: 缓存中查找</span><br><span class="line">cond1=&gt;condition: Yes or No?</span><br><span class="line">op2=&gt;operation: 本地服务器上查找</span><br><span class="line">cond2=&gt;condition: Yes or No?</span><br><span class="line">sub3=&gt;subroutine: 后台TFS集群文件查找</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;e</span><br><span class="line">cond1(no)-&gt;op2(right)-&gt;cond2</span><br><span class="line">cond2(yes)-&gt;e</span><br><span class="line">cond2(no)-&gt;sub3-&gt;e</span><br></pre></td></tr></table></figure><h3 id="淘宝KV缓存系统Tair"><a href="#淘宝KV缓存系统Tair" class="headerlink" title="淘宝KV缓存系统Tair"></a>淘宝KV缓存系统Tair</h3><p><code>TBStore 分布式算法实现</code><br>根据保存的Key关键字，对key进行Hash算法，取得Hash值，再对Hsah值与总Cache服务器数据取，找到服务器列表中下表为此值的Cache服务器。由Java Client API封装实现<br><code>TBstore优缺点</code><br>它是基于Berkeley DB缓存系统的，而Berkeley DB在数据量超过内存的时候，就要往磁盘上写数据了，所以，它是可以做持久化存储的。但是一旦往磁盘写入数据，作为缓存的性能就大幅度下降</p><p><code>UIC （User Information Center）缓存系统 TDBM</code><br>数据全部放在内存中，改进了TDBM的集群分布方式，在内存利用率和吞吐量方面又做了大幅度提升</p><p>TDBM TBStore 的数据接口和用途都十分相似，二者合并推出即<br><a href="https://github.com/alibaba/tair/wiki/%E4%B8%AD%E6%96%87%E4%B8%BB%E9%A1%B5" target="_blank" rel="noopener"><code>Key-Value缓存系统（Tair，Taobao Pair，Pair即Key-Value数据对）</code></a><br>1 Tair包括缓存和持久化两种存储功能。<br>2 分布式系统：由一个中心控制节点Config Server和一系列服务节点Data server组成。<br>3 Config Server负责管理所有的Data Server，维护其状态信息。Data server对外提供各种数据服务，并以心跳形式将吱声的状况汇报给Config Server。<br>4 Config server是控制点，而且是单点，目前采用一主一备来保证其可靠性。所有Data Server 地位等价。</p><p><center><img src="http://www.oschina.net/uploads/img/201009/09100337_hWE9.jpg" alt="Tair架构图"></center><br><a href="https://www.oschina.net/news/89067/yunqi-alibaba-tair" target="_blank" rel="noopener">阿里自研大规模分布式缓存服务 Tair 模块详解</a></p><h2 id="浴火重生"><a href="#浴火重生" class="headerlink" title="浴火重生"></a>浴火重生</h2><p><a href="http://www.aliresearch.com/blog/article/detail/id/17307.html" target="_blank" rel="noopener">淘宝网的技术发展史（三）——分布式时代</a></p><h3 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h3><p><code>catserver和hesper</code> 类目属性 服务化<br>高内聚低耦合 业务的拆分和耦合</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p><code>High-Speed Service Framework</code>实时调用的中间件（淘宝的HSF，高性能服务框架）<br><a href="https://yq.aliyun.com/wenji/274639" target="_blank" rel="noopener">分布式服务框架HSF</a><br><a href="http://www.blogjava.net/BlueDavy/archive/2008/01/24/177533.html" target="_blank" rel="noopener">分析分布式服务框架</a><br><a href="http://www.blogjava.net/BlueDavy/archive/2008/01/14/175054.html" target="_blank" rel="noopener">基于OSGi实现分布式服务框架历程</a><br><code>分布式消息中间件系统</code> 一种是异步消息通知的中间件（淘宝的Notify） </p><p><code>分布式数据访问层TDDL</code>Taobao data distribution layer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据访问路由-将针对数据的读写请求发送到最合适的地方；</span><br><span class="line">数据的多项非对称复制-一次写入，多点读取;</span><br><span class="line">数据存储的自由扩展-不再受限于单台机器的容量瓶颈与速度瓶颈，平滑迁移</span><br></pre></td></tr></table></figure></p><p>稳定 “火车模型”<br>集群：能否集群受限于应用在水平伸缩上的支撑程度，而集群的规模通常会受限于调度、数据库、机房等<br>分工：涉及的主要有按功能和数据库的不同拆分系统等，如何拆分以及拆分后如何交互是需要面临的两个挑战。<br>负载均衡 根据QoS分配资源</p><h3 id="Session框架"><a href="#Session框架" class="headerlink" title="Session框架"></a>Session框架</h3><p>session介绍 可详见  <a href="https://www.zybuluo.com/llplmlyd/note/1247973" target="_blank" rel="noopener">图解HTTP读书笔记</a><br>解决session共享问题：<br>1 硬件负载，将用户请求分发到特定服务器<br>2 Session 复制，就是将用户的Session复制到集群内所有的服务器</p><p>缺点<br>成本较高；性能差，当访问量增大时，带宽增大，机器数量增多，网络负担成指数型上升</p><p><code>Tbsession</code><br>1 Session客户端存储，将session信息存储到客户端浏览器的cookie中<br>2 实现服务端存储，减少cookie使用，增强用户信息安全性，避免流浪器对cookie数量和大小的限制<br>3 session配置统一管理起来，集中管理服务端session和客户端cookie的使用情况，对cookie的使用做有效的监管<br>4 支持动态更新，session的配置动态更新</p><h3 id="开放平台"><a href="#开放平台" class="headerlink" title="开放平台"></a>开放平台</h3><p>Hadoop Memcached？？</p><h4 id="服务路由（外部可以获取内部信息）"><a href="#服务路由（外部可以获取内部信息）" class="headerlink" title="服务路由（外部可以获取内部信息）"></a>服务路由（外部可以获取内部信息）</h4><p>写一个搞笑的httpAgent</p><h4 id="服务接口标准化（统一方式的获得各种标准化信息）"><a href="#服务接口标准化（统一方式的获得各种标准化信息）" class="headerlink" title="服务接口标准化（统一方式的获得各种标准化信息）"></a>服务接口标准化（统一方式的获得各种标准化信息）</h4><p>对象文本化（JSON XML）</p><h4 id="授权（外部合法的获取内部信息）"><a href="#授权（外部合法的获取内部信息）" class="headerlink" title="授权（外部合法的获取内部信息）"></a>授权（外部合法的获取内部信息）</h4><p>OAuth协议</p><p>[参考链接]<a href="https://www.cnblogs.com/me115/p/3545054.html#h20" target="_blank" rel="noopener">《淘宝技术这十年》读书笔记</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“少时淘气，大时淘宝”&lt;br&gt;&lt;img src=&quot;https://app.yinxiang.com/shard/s16/res/ec443bd4-e611-4a03-841f-333d83192889/A9@LTY%5DQG_81BG%7DJB5FMPD.png&quot; alt=
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
