<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Sublime Text 3 快捷键]]></title>
    <url>%2F2018%2F09%2F16%2FSublime%20Text%203%20%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Ctrl+Shift+P：打开命令面板Ctrl+P：搜索项目中的文件Ctrl+G：跳转到第几行Ctrl+W：关闭当前打开文件Ctrl+Shift+W：关闭所有打开文件Ctrl+Shift+V：粘贴并格式化Ctrl+D：选择单词，重复可增加选择下一个相同的单词Ctrl+L：选择行，重复可依次增加选择下一行Ctrl+Shift+L：选择多行Ctrl+Shift+Enter：在当前行前插入新行Ctrl+X：删除当前行Ctrl+M：跳转到对应括号Ctrl+U：软撤销，撤销光标位置Ctrl+J：选择标签内容Ctrl+F：查找内容Ctrl+Shift+F：查找并替换Ctrl+H：替换Ctrl+R：前往 methodCtrl+N：新建窗口Ctrl+K+B：开关侧栏Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身Ctrl+F2：设置/删除标记Ctrl+/：注释当前行Ctrl+Shift+/：当前位置插入注释Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的Ctrl+Shift+A：选择当前标签前后，修改标签用的F11：全屏Shift+F11：全屏免打扰模式，只编辑当前文件Alt+F3：选择所有相同的词Alt+.：闭合标签Alt+Shift+数字：分屏显示Alt+数字：切换打开第N个文件Shift+右键拖动：光标多不，用来更改或插入列内容鼠标的前进后退键可切换Tab文件按Ctrl，依次点击或选取，可需要编辑的多个位置按Ctrl+Shift+上下键，可替换行 选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。Ctrl+M 光标移动至括号内结束或开始的位置。Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。Ctrl+K+0 展开所有折叠代码。Ctrl+← 向左单位性地移动光标，快速移动光标。Ctrl+→ 向右单位性地移动光标，快速移动光标。shift+↑ 向上选中多行。shift+↓ 向下选中多行。Shift+← 向左选中文本。Shift+→ 向右选中文本。Ctrl+Shift+← 向左单位性地选中文本。Ctrl+Shift+→ 向右单位性地选中文本。Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。Ctrl+Shift+D 复制光标所在整行，插入到下一行。Tab 向右缩进。Shift+Tab 向左缩进。Ctrl+K+K 从光标处开始删除代码至行尾。Ctrl+Shift+K 删除整行。Ctrl+/ 注释单行。Ctrl+Shift+/ 注释多行。Ctrl+K+U 转换大写。Ctrl+K+L 转换小写。Ctrl+Z 撤销。Ctrl+Y 恢复撤销。Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。Ctrl+F2 设置书签Ctrl+T 左右字母互换。F6 单词检测拼写 搜索类Ctrl+F 打开底部搜索框，查找关键字。Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。Esc 退出光标多行选择，退出搜索框，命令框等。]]></content>
      <categories>
        <category>Practice</category>
      </categories>
      <tags>
        <tag>Program</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP读书笔记]]></title>
    <url>%2F2018%2F09%2F15%2F%E5%9B%BE%E8%A7%A3HTTP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTTP特性 HTTP 是一个属于应用层的面向对象的协议，HTTP 协议一共有五大特点：12345678910111213141516171819202122232425262728293031323334### 特性解读 `客户/服务器模式, 请求/响应模式` `简单快速` 客户向服务器请求服务时，只需传送请求方法和路径。 `灵活` HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 `无连接` TCP连接是否断开，HTTP/1.0之后的版本默认为持久连接限制每次连接只处理一个请求。请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。容量小时，可节省传输时间。容量大时，则会增加通信量的开销，使得传输效率降低。 `持久连接-Keep alive` 只要任意一端没有明确提出断开连接，则保持TCP连接状态。在建立连接后可进行多次请求与响应 `管线化 pipelining` keep-alive使得pipelining成为可能,可同时并行发送多个请求 `无状态 stateless` HTTP是一种不保存状态，即无状态协议，不对请求和响应之间的通信状态进行保存。HHTP协议的每个请求都是独立的，Keep-Alive 没能改变这个结果。 |优点|缺点:-:|:-:|:-: |更快地处理更多事务，确保协议可伸缩性|没法保存客户机信息,阻碍了交互式应用程序的实现 减少服务器CPU及内存资源消耗|每次请求会传输大量重复的内容信息。 &gt;由此有状态管理: `Cookie` `session` `使用cookie状态管理` cookie机制采用的是在客户端保持状态的方案. `使用 session 状态管理` session机制采用的是在服务器端保持状态的方案，典型的场景比如购物车。Tomcat中将session叫jsession &gt;&gt; [`JSESSIONID和sessionid的区别`](https://blog.csdn.net/czh500/article/details/80216726)### Cookie vs Session `Cookie` 包含用户信息和计算机浏览器信息,根据生命期不同分成两种：会话cookie和持久cookie；会话cookie保存在内存里，浏览器退出即消失。持久cookie为硬盘cookie，设置了过期时间，在过期时间内，存储在硬盘上的cookie可以在不同的浏览器进程间共享。 故根据硬件分类，又分为内存cookie和硬盘cookie，主要用于解决HTTP无状态、无法实现交互式web应用程序的问题，服务器读取cookie，维护用户和服务器会话的状态。Cookie具有不可跨域名性。 主要用途：会话状态管理、个性化设置、浏览器行为跟踪跨站点脚本攻击，cookie盗贼（搜集用户cookie）和cookie投毒（修改传入服务器的cookie） 1`session` 第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器。Session就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户，Session是以Cookie或URL重写为基础的，默认使用Cookie来实现，系统会创造一个名为JSESSIONID的输出Cookie，我们叫Session Cookie,以区别Persistent cookies,也就是我们通常所说的cookie。注意session cookie是存储于浏览器内存中的，并不是写到硬盘上的，即JSESSIONID，通常是看不到JSESSIONID的。 虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。 只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。 禁用cookie后，利用URL重写重写技术，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。12345678910`cookie &amp; session````Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。cookie携带session id后，到服务端session做验证。1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 防session id窃取方案窃取途径：XSS（恶意代码）、CSRF（钓鱼网站），攻击防御防窃取方案：cookie不存放敏感信息和用户不应知道的信息，只存放session id12345设置HttpOnly属性防止XSS攻击。在PHP中，可以通过修改php.ini中的“session.cookie_httponly = 1 ”开启全局Cookie的HttpOnly属性。也可以使用“setcookie”函数来启用。客户端发生变化时，要求用户重新登录。例如使用User-Agent、IP地址、MAC地址等检测请求的一致性,并且加入Token进行检验。更改SessionID名称。例如PHP中SessionID的默认名称是PHPSESSID，此变量会保存在Cookie中，如果攻击者不分析站点，就不能猜到SessionID的名称，阻挡部分攻击。加大SessionID的安全长度，加大暴力猜解难度。为每一次请求生成新的SessionID，特别是登陆前后的 SessionID需要有所不相同，只接受服务器生成的SessionID。设置会话超时属性，设定阈值强制会话过期。 参考链接：Cookie/Session机制详解 HTTP1.0/1.1/2.0 区别HTTP/1.0：多媒体处理，HTTP请求头支持多种请求；连接无法复用，请求分离，线头阻塞（请求无法响应，后面的请求被阻塞）。HTTP/1.1：可扩展性、缓存处理、带宽优化、持久连接、Host头、错误通知、消息传递、内容协商等。12345678910111. 默认持久连接（Connection: keep-alive）和流⽔水线传输（即不用等上一个响应再发下⼀个），关闭：Connection: closed；2. 增加了请求头和响应头来扩充功能：a. 支持Host请求；b. Connection；c. 支持断点续传；d. 身份认证；e. 状态管理；f. Cache缓存处理。3. 状态码100 Continue， POST时大于1024，先询问是否接收（状态码较多，部分由其它RFC定义）4. Host 域：一台物理理主机对应多个虚拟主机-&gt;共享⼀一个ip5. 可分块传输数据：Transfer-Encoding: chunked否则对于动态⽣生成的响应，要把响应整个缓存才知道长度，才能填写Content-Length HTTP/2.0：把解决性能问题的方案内置在了传输层，添加二进制帧分层，通过多路复用来减少延迟，通过压缩 HTTP首部降低开销，同时增加请求优先级和服务器端推送的功能。HTTP/2 简介123456789101112131.支持多路复用 每个来源一个连接，多路复用允许同时通过单一的 HTTP 2.0 连接发起多重的请求-响应消息，即所有HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可，所有数据流共用同一个连接，减少了因http链接多而引起的网络拥塞（在 HTTP1.1 协议中，同一时间，浏览器会针对同一域名下的请求有一定数量限制），解决了慢启动针对突发性和短时性的http链接低效的问题。 流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力。2.将通信的基本单位缩小为帧 请求和响应复用：客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。 HTTP/2 中的新二进制分帧层解决了 HTTP/1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。结果，应用速度更快、开发更简单、部署成本更低。3.首部压缩 HTTP/2 支持DEFLATE和HPACK 算法的压缩，经过专门设计，可以解决发现的安全问题、实现起来也更高效和简单，可以对 HTTP 标头元数据进行良好压缩。（动态索引表）4.服务端推送 客户端请求之前发送数据的机制，在 HTTP 2.0 中，服务器可以对客户端的一个请求发送多个响应，可推送额外的信息。5.请求优先级 HTTP 2.0 使用一个31比特的优先值,0表示最高优先级, 2(31)-1表示最低优先级，服务器端就可以根据优先级，控制资源分配，优先处理和返回最高优先级的请求帧给客户端。 HTTP2.0与WebSocket HTTP 2.0服务器推送不是诸如Server-Sent Events (SSE)或WebSocket的技术替代品。通过HTTP 2.0服务器推送传递过来的资源由浏览器来处理，但却不能上升到程序代码的层面 - 因为没有JavaScript API来获取这些事件的通知。不过，解决这个难题的方法却很简单，因为我们可以把一个SSE通道和服务器推送结合起来，使两者都达到最佳效果。通过HTTP 2.0，服务器有机会变得非常非常智能，包括如何优化传送一些具体的资源，更重要的是，也包括优化对整个应用的传送。类似的，浏览器可能增加额外的API和能力来使这个过程更加高效。在HTTP/2中，在场景后面使用服务器推送来提高客户端从浏览器加载资源的能力。作为一个开发人员，你在开发过程中并不真正关心它。但是，使用WebSocket，开发人员可以使用API，该API能够使用唯一的全双工连接来使用和推送消息。 1 补充关系 二者侧重点不同。SPDY更侧重给Web页面的加载提速，而websocket更强调为web应用提供一种双向的通信机制以及API2 竞争关系，二者解决的问题有交集，比如在服务器上推送上SPDY和Websocket都提供了方案3 承载关系，SPDY若标准化早于websocket，则websocket完全可以侧重于API，利用SPDY的帧机制和多路复用机制实现该API4 融合关系，如微软在HTTP Speed+Mobility中所做 HTTP实现HTTP在TCP/IP的通信传输流12345678#每通过一层都进行一次封装 应用层 HTTP客户端 HTTP服务器 #HTTP报文 HTTP数据 ↓ ↑ 传输层 TCP TCP #TCP报文段 TCP首部 ↓ ↑ 网络层 IP IP #IP数据包 IP首部 ↓ ↑ 链路层 网络 → 网络 #网络架构 以太网首部 各协议与HTTP协议的关系（TCP/IP DNS） 输入域名(url)–&gt;DNS映射为IP–&gt;TCP三次握手–&gt;HTTP请求–&gt;HTTP响应–&gt;(浏览器跟踪重定向地址)–&gt;服务器处理请求–&gt;服务器返回一个html响应–&gt;(视情况决定释放TCP连接)–&gt;客户端解析HTML–&gt;获取嵌入在HTML中的对象重新发起http请求123456789101112131415161718st=&gt;start: 输入域名op1=&gt;operation: DNS映射为IPop2=&gt;operation: TCP三次握手op3=&gt;operation: HTTP请求cond=&gt;condition: url是否正确否则重定向op5=&gt;operation: 服务器处理请求op4=&gt;operation: 服务器返回html响应e=&gt;end: 客户端浏览器解析响应报文st(right)-&gt;op1op1(right)-&gt;op2op2-&gt;op3op3-&gt;condcond-&gt;op5cond(no)-&gt;op3cond(yes)-&gt;op5op5(right)-&gt;op4op4(right)-&gt;e HTTP重定向和转发1.实际发生位置不同，地址栏不同 重定向是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化的。实现重定向的原理是由response的状态码和Location头组合而实现的。这是由浏览器进行的页面跳转实现重定向会发出两个http请求，**request域对象是无效的，因为它不是同一个request对象 转发是由服务器进行跳转的，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问Servlet111的时候，即使跳转到了Servlet222的页面，浏览器的地址还是Servlet111的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的http请求，一次转发中request和response对象都是同一个。这也解释了，为什么可以使用request作为域对象进行Servlet之间的通讯。 转发是发生在服务器的 重定向是发生在浏览器的 2.用法不同 重定向时”/“代表的是webapps目录 转发时”/“代表的是本应用程序的根目录 资源地址书写：给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上 request.getRequestDispatcher(“/资源名 URI”).forward(request,response) response.send(“/web应用/资源名 URI”); 3.能够去往的URL的范围不一样 转发是服务器跳转只能去往当前web应用的资源 重定向是服务器跳转，可以去往任何的资源 4.传递数据的类型不同 转发的request对象可以传递各种类型的数据，包括对象 重定向只能传递字符串 5.跳转的时间不同 转发时：执行到跳转语句时就会立刻跳转 重定向：整个页面执行完之后才执行跳转 HTTP请求/响应的步骤12345678910st=&gt;start: 客户端连接到web服务器op1=&gt;operation: 客户端发送HTTP请求op2=&gt;operation: 服务器端解析请求并返回HTTP响应op3=&gt;operation: 释放TCP连接e=&gt;end: 客户端浏览器解析响应报文st-&gt;op1op1-&gt;op2op2-&gt;op3op3-&gt;e 浏览器解析和渲染(边解析边渲染)从输入URL到页面加载发生了什么HTML文件构建DOM树–&gt;CSS文件构建CSSOM树–&gt;构建渲染树和布局–&gt;JS代码加载–&gt;页面绘制和渲染js代码渲染完成后html才能进行html渲染 12345678910st1=&gt;start: op1=&gt;operation: HTML文件构建DOM树op2=&gt;operation: CSS构建渲染树op3=&gt;operation: 布局渲染树e=&gt;end: 页面绘制和渲染st1-&gt;op1op1-&gt;op2op2-&gt;op3op3-&gt;e HTTP优化负载均衡技术、TCP连接复用（多个客户端的HTTP请求复用到一个服务器端TCP连接上）、HTTP复用（管道pipelining）、内容缓存、TCP缓冲（解决后端服务器网速与客户的前端网络速度不匹配而造成的服务器资源浪费的问题）、HTTP压缩（对客户端的响应请求进行压缩处理：gzip、compress、deflate、identity）、SSL加速。 Http应用优化和加速说明-负载均衡浅谈 C/S 和 B/S 架构 HTTP报文信息报文结构报文首部+（CR+CF）+报文主体请求报文请求行 首部字段 其他（如cookie等）响应报文状态行 首部字段 其他（如cookie等） GET vs POSTGET - 请求来自指定资源的数据POST - 将要处理的数据提交给指定的资源|GET|POST:-:|:-:|:-:GET请求可以被缓存|POST请求永远不会被缓存GET请求保留在浏览器历史记录中|POST不保留在浏览器历史记录中GET请求可以加书签|POST请求不能加书签在处理敏感数据时绝不能使用GET请求|POST请求对数据长度没有限制GET请求有长度限制|GET请求只能用于检索数据| 常用的HTTP方法GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。MOVE：请求服务器将指定页面移至另一台服务器。OPTIONS：查询相应URI支持的HTTP方法。 HTTP状态码12345678910111213141516171819201xx：指示信息--表示请求已接收，继续处理2xx：成功--表示请求已被成功接收、理解、接受 200：请求被正常处理 204：请求被受理但没有资源可以返回 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。3xx：重定向--要完成请求必须进行更进一步的操作 301：永久性重定向 302：临时重定向 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上 304：发送附带条件的请求时，条件不满足时返回，与重定向无关 307：临时重定向，与302类似，只是强制要求使用POST方法4xx：客户端错误--请求有语法错误或请求无法实现 400：请求报文语法有误，服务器无法识别 401：请求需要认证 403：请求的对应资源禁止被访问 404：服务器无法找到对应资源5xx：服务器端错误--服务器未能实现合法的请求 500：服务器内部错误 502：错误网关，作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。， 503：临时的服务器维护或者过载，服务器当前无法处理请求 HTTP首部a、通用首部字段（请求报文与响应报文都会使用的首部字段）Date：创建报文时间Connection：连接的管理Cache-Control：缓存的控制Transfer-Encoding：报文主体的传输编码方式 b、请求首部字段（请求报文会使用的首部字段）Host：请求资源所在服务器Accept：可处理的媒体类型Accept-Charset：可接收的字符集Accept-Encoding：可接受的内容编码Accept-Language：可接受的自然语言 c、响应首部字段（响应报文会使用的首部字段）Accept-Ranges：可接受的字节范围Location：令客户端重新定向到的URIServer：HTTP服务器的安装信息 d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）Allow：资源可支持的HTTP方法Content-Type：实体主类的类型Content-Encoding：实体主体适用的编码方式Content-Language：实体主体的自然语言Content-Length：实体主体的的字节数Content-Range：实体主体的位置范围，一般用于发出部分请求时使用 HTTPSHTTP缺点1 通信使用明文（不加密）可能被窃听2 不验证通信方身份 有可能遭遇伪装3 无法证明报文完整性 有可能已遭篡改 HTTPS=HTTP+加密处理（一般是SSL安全通信线路）+认证+完整性保护1 HTTPS协议需要申请到ca证书，一般免费证书较少，因而需要一定费用。2 HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议。3 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4 HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全HTTPS通信过程： HTTPS通信活动-&gt; 客户端向服务端发送请求-&gt; 服务端返回数字证书（hash（服务器身份和公钥）–&gt;信息摘要–&gt;CA私钥加密信息摘要–&gt;数字签名；数字签名+原始信息=数字证书）-&gt; 客户端用自己的CA[主流的CA机构证书一般都内置在各个主流浏览器中]公钥去解密证书，验证信息摘要，如果证书有问题会提示风险-&gt; 如果证书没问题客户端会生成一个对称加密的随机秘钥然后再和刚刚解密的服务器端的公钥对数据进行加密,然后发送给服务器端-&gt; 服务器端收到以后会用自己的私钥对客户端发来的对称秘钥进行解密-&gt; 之后双方就拿着这个对称加密秘钥来进行正常的通信 HTTP局限SSL 慢：处理通信量增加，通信慢；处理速度慢，SSL必须进行加密处理，消耗了大量的CPU及内存资源，负载增强SSL解决方案：使用SSL加速器（专用服务器） SSL/TSL加密SSL (Secure Socket Layer)SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。使用： 1）认证用户和服务器，确保数据发送到正确的客户机和服务器； 2）加密数据以防止数据中途被窃取； 3）维护数据的完整性，确保数据在传输过程中不被改变。 TLS 协议TLS(Transport Layer Security Protocol)：安全传输层协议 ：TLS记录协议是一种分层协议。每一层中的信息可能包含长度、描述和内容等字段。记录协议支持信息传输、将数据分段到可处理块、压缩数据、应用MAC 、加密以及传输结果等。对接收到的数据进行解密、校验、解压缩、重组等，然后将它们传送到高层客户机。TLS连接状态指的是TLS记录协议的操作环境。它规定了压缩算法、加密算法和MAC算法。TLS记录层从高层接收任意大小无空块的连续数据。密钥计算：记录协议通过算法从握手协议提供的安全参数中产生密钥、 IV 和MAC密钥。TLS 握手协议由三个子协议组构成，允许对等双方在记录层的安全参数上达成一致、自我认证、例示协商安全参数、互相报告出错条件。 TLS&amp;SSLTLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS 在SSL v3.0 的基础上，提供了以下增强内容：1）更安全的MAC算法2）更严密的警报3）“灰色区域”规范的更明确的定义TLS对于安全性的改进1）对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。2）增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。3）改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。4）一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。5）特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。 Web攻击技术 详见白帽子讲Web安全]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F09%2F15%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一个正则表达式通常被称为一个模式（pattern） 基本语法选择竖线|代表选择（即或集），具有最低优先级。例如gray|grey可以匹配grey或gray 数量限定+、?和*1加号+代表前面的字符必须至少出现一次。（1次或多次）。例如，goo+gle可以匹配google、gooogle、goooogle等; 1问号?代表前面的字符最多只可以出现一次。（0次或1次）。例如，colou?r可以匹配color或者colour; 1星号*代表前面的字符可以不出现，也可以出现一次或者多次。（0次、1次或多次）。例如，0*42可以匹配42、042、0042、00042等。 匹配圆括号()可以用来定义操作符的范围和优先度例如，gr(a|e)y等价于gray|grey要做更精确地匹配，可以用[]表示范围 [0-9a-zA-Z_]可以匹配一个数字、字母或者下划线；[0-9a-zA-Z_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如’a100’，’0_Z’，’Py3000’等等；[a-zA-Z_][0-9a-zA-Z_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；[a-zA-Z_][0-9a-zA-Z_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 表达式全集适用于Perl或者Python编程语言（grep或者egrep的正则表达式文法是PCRE的子集）： \ “\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(” ^ 匹配输入字符串的开始位置 $ 匹配输入字符串的结束位置 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。 . 匹配除“\r”“\n”之外的任何单个字符。要匹配包括“\r”“\n”在内的任何字符，请使用像“(. \r \n)”的模式。 (?:pattern) 匹配pattern但不获取匹配的子字符串（shy groups），也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。这在使用或字符“( )”来组合一个模式的各个部分是很有用。例如“industr(?:y ies)”就是一个比“industry industries”更简略的表达式。 [xyz] 字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 排除型字符集合（negated character classes）。 [a-z] 字符范围。匹配指定范围内的任意字符。 \d 匹配一个数字字符。 \D 匹配一个非数字字符。 \f 匹配一个换页符。 \n 匹配一个换行符。 \r 匹配一个回车符 \s 匹配任何空白字符， \S 匹配任何非空白字符 \t 匹配一个制表符 \v 匹配一个垂直制表符。 https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F正则匹配URL：[a-zA-z]+://[^\s]* 正则测试网站：http://tool.oschina.net/regex#]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Raid0,Raid1,Raid3,Raid5(6),Raid10（0+1/1+0）的总结]]></title>
    <url>%2F2018%2F09%2F15%2F%E5%85%B3%E4%BA%8ERaid0%2CRaid1%2CRaid3%2CRaid5(6)%2CRaid10%EF%BC%880%2B1_1%2B0%EF%BC%89%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[RAID0 - 条带化，串連 (Striping) 硬盘数&gt;=2定义 多磁盘数据分组同步读写 读写速度为单盘的X倍RAID级别中的存储性能最高。将多个磁盘并列起来，成为一个大磁盘 raid0，将连续的数据分散到多个磁盘上存取，系统有数据请求就可以被多个磁盘并行的执行，每个磁盘执行属于它自己的那部分数据请求。这种数据上的并行操作可以充分利用总线的带宽，显著提高磁盘整体存取性能。raid功能中spanning和striping模式有什么区别? 工作原理系统向三个磁盘组成的逻辑硬盘（RAID0磁盘组）发出的I/O数据请求被转化为3项操作，其中的每一项操作都对应于一块物理硬盘。通过建立RAID 0，原先顺序的数据请求被分散到所有的三块硬盘中同时执行。从理论上讲，三块硬盘的并行操作使同一时间内磁盘读写速度提升了3倍。 但由于总线带宽等多种因素的影响，实际的提升速率肯定会低于理论值，但是，大量数据并行传输与串行传输比较，提速效果显著显然毋庸置疑。 优缺点1、读写性能高，非常适合于视频、图像的制作和编辑2、安全性能低，不支持数据冗余，无容错功能，不适用于关键任务环境3、磁盘空间使用率：100%，成本最低4、在 RAID0 串連中的每個磁碟必須要相同大小 RAID1 - Block 鏡像 (Mirroring) 硬盘数&gt;=2定义 多磁盘同数据同步写读 读写速度与单盘相同RAID 1通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能。 工作原理将一个两块硬盘所构成RAID磁盘阵列，其容量仅等于一块硬盘的容量，因为另一块只是当作数据“镜像”。读只能在一块磁盘上进行，并不会进行并行读取，性能取决于硬盘中较快的一块。写的话通常比单块磁盘要慢，虽然是并行写，即对两块磁盘的写入是同时进行的，但因为要比较两块硬盘中的数据，所以性能比单块磁盘慢。 优缺点1、磁盘的利用率却只有50%，磁盘利用率最低，成本最高2、数据冗余备份，容错，数据安全性高；当故障发生时，系统可自动切换到镜像磁盘，无需重组数据3、读性能：只能在一个磁盘上读取，取决于磁盘中较快的那块盘4、写性能：两块磁盘都要写入，虽然是并行写入，但因为要比对，故性能单块磁盘慢。5、支持“热交换”，就是说阵列中硬盘的移除或替换可以在系统运行时进行，无须中断退出系统。 RAID3 - 位元級串連與獨立奇偶校驗 校验存储与一个盘 硬盘数&gt;=3定义RAID 3是把数据分成多个“块”，按照一定的容错算法，存放在N+1个硬盘上，实际数据占用的有效空间为N个硬盘的空间总和，而第N+1个硬盘上存储的数据是校验容错信息 工作原理当这N+1个硬盘中的其中一个硬盘出现故障时，从其它N个硬盘中的数据也可以恢复原始数据，这样，仅使用这N个硬盘也可以带伤继续工作（如采集和回放素材），当更换一个新硬盘后，系统可以重新恢复完整的校验容错信息。由于在一个硬盘阵列中，多于一个硬盘同时出现故障率的几率很小，所以一般情况下，使用RAID3，安全性是可以得到保障的。 优缺点1、写入操作多磁盘并行进行，但每个数据盘写入数据，都需要同时重写校验盘中的相关信息，经常执行写入，会导致校验盘负载压力大2、更加适合应用于那些写入操作较少，读取操作较多的应用环境，例如 数据库和WEB服务器等 Raid5 分布式奇偶校验 硬盘数&gt;=3 定义RAID 5是RAID 0和RAID1的折中方案。RAID5具有和RAID0相近似的数据读取速度，只是多了一个奇偶校验信息，写入数据的速度比对单个磁盘进行写入操作稍慢。 工作原理RAID5把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且是分别存储于不同的磁盘上，其中任意N-1块磁盘上都存储完整的数据，也就是说有相当于一块磁盘容量的空间用于存储奇偶校验信息。当RAID5的一个磁盘发生损坏后，不会影响数据的完整性，从而保证了数据安全。当损坏的磁盘被替换后，RAID还会自动利用剩下奇偶校验信息去重建此磁盘上的数据，来保持RAID5的高可靠性。 优缺点1、磁盘空间利用率：(N-1)/N，即只浪费一块磁盘用于奇偶校验。存储成本相对较低2、(n-1)*单块磁盘的读性能，和RAID0相近似的数据读取速度3、写入数据的速度比对单个磁盘进行写入操作稍慢4、高可靠性。奇偶校检与数据分别都存储不同盘，损坏时，可以自动重建。只允许一块磁盘损坏。 附 Raid6类似RAID5两组奇偶校验信息块，两个独立的奇偶系统使用不同的算法， 数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。相对于RAID 5有更大的“写损失”，因此“写性能”非常差。 Raid10：RAID1+0和RAID0+1 硬盘&gt;=4 (偶数）Raid10 镜象阵列条带 先做镜像(1)，再做条带(0)可以理解为两个raid0同步Raid01 先做条带(0)，再做镜像(1) 工作原理Raid10其实结构非常简单，首先创建2个独立的Raid1，然后将这两个独立的Raid1组成一个Raid0，当往这个逻辑Raid中写数据时，数据被有序的写入两个Raid1中。磁盘1和磁盘2组成一个Raid1，磁盘3和磁盘4又组成另外一个Raid1;这两个Raid1组成了一个新的Raid0。 优缺点：1、磁盘利用率50% 成本较高2、安全性上RAID10要好于 RAID01，如图中所示，假设DISK0损坏，在RAID10中，只有DISK1 故障，整个RAID才失效。故障率为1/3。但在RAID01中，DISK0损坏后，左边的条带将无法读取，DISK2或DISK3两个盘中任何一个损坏，都会导致RAID失效。故障率2/3。3、RAID01比起RAID10有着更快的读写速度 Raid10 与 Raid5 比较1、RAID5和RAID10，哪种RAID更适合你(上)2、RAID5和RAID10，哪种RAID更适合你(下) 参考链接https://www.cnblogs.com/ivictor/p/6099807.htmlhttp://blog.jobbole.com/83808/https://blog.csdn.net/spuer_io/article/details/57080239https://www.freebsd.org/doc/zh_TW/books/handbook/geom.htmlhttp://blog.51cto.com/jiebers/1334486http://blog.51cto.com/jiebers/1334487]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XPath]]></title>
    <url>%2F2018%2F09%2F10%2FXPath%2F</url>
    <content type="text"><![CDATA[XPath is a major element in the XSLT standard. XPath can be used to navigate through elements and attributes in an XML document. XPath stands for XML Path Language. XPath uses “path like” syntax to identify and navigate nodes in an XML document. HtmL文件下载]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“淘宝技术这十年”]]></title>
    <url>%2F2018%2F09%2F10%2F%E2%80%9C%E6%B7%98%E5%AE%9D%E6%8A%80%E6%9C%AF%E8%BF%99%E5%8D%81%E5%B9%B4%E2%80%9D%2F</url>
    <content type="text"><![CDATA[“少时淘气，大时淘宝” 时势造英雄起因eBay 易趣 在资本方面对仗，阿里想趁此崛起新项目就要求能在短时间内做出一个 个人对个人的商品交易网站（C2C）2003年4月7日-5月10日 一个月 淘宝技术团队采取购买方案 需求分析自建|购入:-:|:-时间成本高，故不采用|要求比较低的维护成本；方便扩展和二次开发；轻量、简单 LAMP Linux+Apache+MySQL+PHP优点：无须编译，发布快速；PHP语言功能强大，能做到从页面渲染到数据访问所有的事情，且用到的技术都是开源免费的 提供淘宝网站系统的官网：PHPAuction 购入后修改增加后台管理功能、修改页面模板、页眉页脚加上自己站点简介；数据库拆分：拆分成一个主库+连个从库，并且读写分离 数据库拆分优点存储容量增加；备份提高数据安全性；读写分离提升读写效率 淘宝网”个人网站”即横空出世了 这个第一版系统中包含商品发布、管理、搜索、商品详情、出价购买、评价投诉、我的淘宝等功能 系统改进 背景：用户需求、流量增长、数据库资源增大 服务器：由一台变成了三台 Email + 运行数据库 + 运行WebApp 数据库搜索： like → isearch 问题短板 访问量和数据量的飞涨，数据库的性能缺陷突出： 1 当Master同步数据到Slave时，会引起Slave写，此时的Slave读操作都需要等待。 2 同时会发生Slave的主键冲突，经常导致同步停止，使得查询失败。 打怪升级在前述的问题短板的情况下，阿里必须提出技术解决方案： 把MySQL换成Oracle Oracle优点：容量大、稳定、安全、性能高人才条件：阿里有顶尖团队 更换数据库访问方式 + SQL语法 + 连接池设计（关键） 存在的问题连接池连接池中放的是长连接，是进程级别的，在创建进程的时候，要独占一分部分内存空间，这部分连接数在固定内存的Oracle server上是有限的，任何一个请求只需要从连接池中取得一个连接即可，用完后释放，不需要频发地创建和断开连接，要知道连接的创建与断开开销是非常大的。PHP语言对数据库的访问很直接，每一个请求都需要一个连接。如果是长连接，应用故武器增多时，连接数就多了，就会把数据库拖挂；而如果是短连接，频繁得连接再断开 数据库性能会非常差 解决方案开源的连接池代理服务 SQL Relay 遗留问题SQL Relay死锁 只能靠重启服务解决 存储扩容NAS 数据库存储设备（Network Appliance）+ Oracle RAC（Real Application Clusters，实时应用集群）实现负载均衡NAS的NFS文件系统协议传输延迟很严重↓改用了Dell和EMC合作的SAN低端存储数据量的增大→存储结点的不断拆分↓RAC出现问题购买小型机 支付手段创新-支付宝安全交易、第三方托管、开发与银行网关对接功能 交流方式创新-淘宝旺旺脱胎换骨 边换边跑“好的架构图充满美感”。第二幅架构图显得头重脚轻，不是个稳定的版本，打怪的时候还是留下了祸根，SQL relay的问题无法解决，数据库必须使用oracle。 换开发语言 PHP → JAVAJAVA成熟的网站开发语言 比较良好的企业开发框架 开发经验人才多 后续维护成本比较低 有很多现成的连接池Sun公司创建java语言的开发公司，eBay的网站也经历过从C++到java的类似开发语言换骨，也是由Sun公司完成的。淘宝也请了Sun公司为淘宝主刀 要求迁移过程中不停止服务，原系统的bugfix和功能改进不受影响。 方案给业务分模块，一个一个模块地渐进式替换。如用户模块，老的member.taobao.com继续维护，不添加新功能，新的功能先在新的模块上开发，跟老的共用一个数据库，开发完毕之后放到不同的应用集群上，另开个域名 member1.taobao.com，同时替换老的功能，替换一个，把老的模块上的功能关闭一个，逐渐的把用户引导到 member1.taobao.com，等所有功能都替换完毕之后，关闭 member.taobao.com。 小问题二级域名member1.taobao.com应该是个过度状态，但却很难把member1切换回member，因为有些地方连接已经写死了 开发模式Java MVC struts1.x在多人协作方面有很多致命弱点，没有轻量框架作为基础，很难扩展WebX阿里巴巴 周悦虹 在 JAkarta Turbine 的基础上做了很多扩展 打造了一个阿里巴巴自己用的MVC框架 WebX。该框架易于扩展 方便组件化开发，页面模板支持 JSP 和 Velocity ，持久层支持ibatis 和 hibernate 等，控制层可以用EJB和Spring 性能 容量 成本的进化数据库扩展Oracle “分库分表”：把用户的信息按照ID来存放到两个数据库汇总DB1DB2，把商品信息和卖家信息放在两个对应的数据库里面，把商品类目等通用信息放在第三个库里面(DBcommon)。这么做的目的除了增加了数据库的容量之外，还有一个就是做容灾，万一一个数据库挂了，整个网站上还有一半的数据能操作。 数据的合并、排序、分页DBRoute，统一数据的合并、排序、分页，该框架一直延续在Oracle时段。SpringEJB → Spring 系统精简了代码缓存 CDN（内容分发网络）缓存初型：Berkeley DB缓存系统，该缓存系统性能比较弱，存放不太变动的只读信息。CDN 起初采用China Cache 后改用自己开发的CDN 脱胎换骨架构图 去IOE （IBM小型机 Oracle EMC存储） 创新技术“用钱能解决的问题 都不是问题” 业务推动创新 创新推动业务 淘宝文件系统TFS商用存储系统的局限1 没有对小文件存储和读取环境进行针对性优化2 文件数量大 网络存储设备无法支撑3 系统所连接服务器越来越多4 商用存储系统扩容成本高，存在单点故障，容灾和安全性无法得到保障 商用系统和自主研发之间的经济效益对比1 商用软件很难满足大规模系统的应用需求，无论存储还是CDN还是负载均衡，因为在厂商实验室端，很难实现如此大的数据规模测试。2 研发过程中，将开源和自主开发相结合，会有更好的可控性，系统出问题了，完全可以从底层解决问题，系统扩展性也更高。3 在一定规模效应基础上，研发的投入都是值得的。上图是一个自主研发和购买商用系统的投入产出比对比，实际上，在上图的交叉点左边，购买商用系统都是更加实际和经济性更好的选择，只有在规模超过交叉点的情况下，自主研发才能收到较好的经济效果。实际上，规模化达到如此程度的公司其实并不多，不过淘宝网已经远远超过了交叉点。 TFS存储需求 文件比较小；并发量高；读操作远大于写操作；访问随机；没有文件修改的操作；要求存储成本低；能容灾能备份。应对这种需求，显然要用分布式存储系统；由于文件大小比较统一，可以采用专有文件系统；并发量高，读写随机性强，需要更少的 IO 操作；考虑到成本和备份，需要用廉价的存储设备；考虑到容灾，需要能平滑扩容。 参照GFS 产生的TFSv1.0： 4 自主研发的系统可在软件和硬件多个层次不断的优化。 在这个架构中： • 每个 Data Server 运行在一台普通的 Linux 主机上 • 以 block 文件的形式存放数据文件(一般64M一个block ) • block 存多份保证数据安全 • 利用 ext3 文件系统存放数据文件 • 磁盘 raid5 做数据冗余 • 文件名内置元数据信息，用户自己保存TFS文件名与实际文件的对照关系 – 使得元数据量特别小。 淘宝 TFS 文件系统在核心设计上最大的取巧的地方就在，传统的集群系统里面元数据只有1份，通常由管理节点来管理，因而很容易成为瓶颈。而对于淘宝网的用户来说，图片文件究竟用什么名字来保存实际上用户并不关心，因此TFS在设计规划上考虑在图片的保存文件名上暗藏了一些元数据信息，例如图片的大小、时间、访问频次等等信息，包括所在的逻辑块号。而在元数据上，实际上保存的信息很少，因此元数据结构非常简单。仅仅只需要一个fileID，能够准确定位文件在什么地方。 由于大量的文件信息都隐藏在文件名中，整个系统完全抛弃了传统的目录树结构，因为目录树开销最大。拿掉后，整个集群的高可扩展性极大提高。实际上，这一设计理念和目前业界的“对象存储”较为类似，淘宝网 TFS 文件系统已经更新到 1.3 版本， TFS1.3重点改善心跳和同步性能、元数据存储在内存中，清理磁盘空间等性能优化：123456采用ext4文件系统 并且预分配文件 减少ext3等文件系统数据碎片带来的性能损耗；单进程管理单块磁盘的方式，摒除RAID5机制带有HA机制的重要控制节点，在安全稳定和性能复制度之间取得平衡缩减元数据大小，将更多的元数据加载如内存，提升访问速度跨级计啊和IDC负载均衡及冗余安全策略完全平滑扩容 图片文件服务器部署在TFS前端，用Apache实现，缩略图实时生成1 避免后端图片服务器上存储的图片数量过多，大大节约了后台存储空间的需求2 缩略图可实时生成，更加灵活3 采用一级缓存和二级缓存，前面还有全局负载均衡的设置 淘宝网缓存策略：淘宝网在各个运营商中心点设有二级缓存，整体系统中心店设有一级缓存，加上全局负载均衡，传递到后端的TFS流量就已经非常均衡和分散了，对前端的响应性能也大大提升。淘宝大部分图片都尽量在缓存中命中，如果无法命中，则在本地服务器上查找手否存有原图，并根据原图生产缩略图，如果都没有命中，则考虑去后台TFS集群文件存储系统上调取。 12345678910111213st=&gt;start: Startop1=&gt;operation: 缓存中查找cond1=&gt;condition: Yes or No?op2=&gt;operation: 本地服务器上查找cond2=&gt;condition: Yes or No?sub3=&gt;subroutine: 后台TFS集群文件查找e=&gt;endst-&gt;op1-&gt;cond1cond1(yes)-&gt;econd1(no)-&gt;op2(right)-&gt;cond2cond2(yes)-&gt;econd2(no)-&gt;sub3-&gt;e 淘宝KV缓存系统TairTBStore 分布式算法实现根据保存的Key关键字，对key进行Hash算法，取得Hash值，再对Hsah值与总Cache服务器数据取，找到服务器列表中下表为此值的Cache服务器。由Java Client API封装实现TBstore优缺点它是基于Berkeley DB缓存系统的，而Berkeley DB在数据量超过内存的时候，就要往磁盘上写数据了，所以，它是可以做持久化存储的。但是一旦往磁盘写入数据，作为缓存的性能就大幅度下降 UIC （User Information Center）缓存系统 TDBM数据全部放在内存中，改进了TDBM的集群分布方式，在内存利用率和吞吐量方面又做了大幅度提升 TDBM TBStore 的数据接口和用途都十分相似，二者合并推出即Key-Value缓存系统（Tair，Taobao Pair，Pair即Key-Value数据对）1 Tair包括缓存和持久化两种存储功能。2 分布式系统：由一个中心控制节点Config Server和一系列服务节点Data server组成。3 Config Server负责管理所有的Data Server，维护其状态信息。Data server对外提供各种数据服务，并以心跳形式将吱声的状况汇报给Config Server。4 Config server是控制点，而且是单点，目前采用一主一备来保证其可靠性。所有Data Server 地位等价。 阿里自研大规模分布式缓存服务 Tair 模块详解 浴火重生淘宝网的技术发展史（三）——分布式时代 服务化catserver和hesper 类目属性 服务化高内聚低耦合 业务的拆分和耦合 中间件High-Speed Service Framework实时调用的中间件（淘宝的HSF，高性能服务框架）分布式服务框架HSF分析分布式服务框架基于OSGi实现分布式服务框架历程分布式消息中间件系统 一种是异步消息通知的中间件（淘宝的Notify） 分布式数据访问层TDDLTaobao data distribution layer123数据访问路由-将针对数据的读写请求发送到最合适的地方；数据的多项非对称复制-一次写入，多点读取;数据存储的自由扩展-不再受限于单台机器的容量瓶颈与速度瓶颈，平滑迁移 稳定 “火车模型”集群：能否集群受限于应用在水平伸缩上的支撑程度，而集群的规模通常会受限于调度、数据库、机房等分工：涉及的主要有按功能和数据库的不同拆分系统等，如何拆分以及拆分后如何交互是需要面临的两个挑战。负载均衡 根据QoS分配资源 Session框架session介绍 可详见 图解HTTP读书笔记解决session共享问题：1 硬件负载，将用户请求分发到特定服务器2 Session 复制，就是将用户的Session复制到集群内所有的服务器 缺点成本较高；性能差，当访问量增大时，带宽增大，机器数量增多，网络负担成指数型上升 Tbsession1 Session客户端存储，将session信息存储到客户端浏览器的cookie中2 实现服务端存储，减少cookie使用，增强用户信息安全性，避免流浪器对cookie数量和大小的限制3 session配置统一管理起来，集中管理服务端session和客户端cookie的使用情况，对cookie的使用做有效的监管4 支持动态更新，session的配置动态更新 开放平台Hadoop Memcached？？ 服务路由（外部可以获取内部信息）写一个搞笑的httpAgent 服务接口标准化（统一方式的获得各种标准化信息）对象文本化（JSON XML） 授权（外部合法的获取内部信息）OAuth协议 [参考链接]《淘宝技术这十年》读书笔记]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理（三）之进程]]></title>
    <url>%2F2018%2F09%2F03%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程的定义一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 进程的组成 进程包含了正在运行的一个程序的所有状态信息 程序的代码； 程序处理的数据； 程序计数器中的值，指示下一条将运行的指令； 一组通用的寄存器的当前值，堆、栈； （如打开的文件）； 进程与程序的联系 程序是产生进程的基础 程序的每次运行构成不同的进程 进程是程序功能的体现 通过多次执行，一个程序可对应多个进程； 通过调用关系，一个进程可包括多个程序 进程和程序的区别进程是动态的，程序是静态的程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态进程是暂时的，程序是永久的进程是一个状态变化的过程，程序可长久保存进程与程序的组成不同进程的组成包括程序、数据和进程控制块（即进程状态信息） 进程的特点动态性：可动态地创建、结束进程并发性：进程可以被独立调度并占用处理机运行独立性：不同进程的工作不相互影响制约性：因访问共享数据/资源或进程间同步而产生制约 进程控制块结构进程控制块：操作系统管理控制进程运行所用的信息集合操作系统用PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志 使用进程控制块进程的创建：为该进程生成一个PCB进程的终止：回收它的PCB进程的组织管理：通过PCB的组织管理来实现 PCB含有以下三大类信息 进程标识信息如本进程的标识，本进程的产生者标识（父进程标识），用户标识 处理机状态信息保存区。用户可见寄存器，用户程序可以使用的数据、地址等寄存器控制和状态寄存器，如程序计数器（PC）、程序状态字（PSW）栈指针，过程调用/系统调用/中断处理/和返回时需要用它 保存进程的运行现场信息 PCB的组织方式链表同一状态的进程其PCB成一链表，多个状态对应多个不同的链表各状态的进程形成不同的链表：就绪链表、阻塞链表索引表同一状态的进程归入一个index表（有index指向PCB），多个状态对应多个不同的index表各状态的进程形成不同的索引表：就绪索引表、阻塞索引表 进程的生命周期管理进程创建系统初始化时用户请求创建一个新进程正在运行的进程执行了创建进程的系统调用进程运行内核选择一个就绪的进程进程等待进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生进程唤醒将该进程的PCB插入到就绪队列 且 进程只能被别的进程或操作系统唤醒进程结束正常退出（自愿的）错误退出（自愿的）致命错误（强制性的）被其他进程所杀（强制性的) 进程状态变化模型基本状态运行状态（Running）当一个进程正在处理机上运行时就绪状态（Ready）一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行等待状态（又称阻塞状态 Blocked）一个进程正在等待某一时间而暂停运行时。如等待某资源，等待输入/输出完成 基本过程（状态点）创建状态（New）一个进程正在被创建，还没被转到就绪状态之前的状态结束状态（Exit）一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因。 可能的状态变化如下 Null -&gt; New：一个新进程被产生出来执行一个程序 New -&gt; Ready：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态（时间很短） Ready -&gt; Running：处于就绪状态的进程被进程调度程序选中后，就分配到处理机上来运行 Running -&gt; Ready：处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机（操作系统完成） Running -&gt; Blocked：当进程请求某样东西且必须等待时Blocked -&gt; Ready：当进程要等待某事件到来时，它从阻塞状态变到就绪状态 进程挂起进程没有占用内存空间。处在挂起状态的进程映像在外存中 挂起状态阻塞挂起状态（Blocked-suspend）进程在外存并等待某事件的出现就绪挂起状态（Ready-suspend）进程在外存，但只要进入内存，即可运行； 状态转换挂起（suspend）：内存→外存 阻塞到阻塞挂起： 没有进程处于就绪状态或就绪状态进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程。 就绪到就绪挂起：当有高优先级阻塞（系统认为很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程。 运行到就绪挂起：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态。 转换后仍在外存 阻塞挂起到就绪挂起：当有阻塞挂起进程因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。 解挂/激活（Activate）：外存→内存 就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换。 阻塞挂起到阻塞：当一个进程释放足够多内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程。 状态队列 由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态； 不同的状态分别用不同的队列表示（就绪队列、各种类型的阻塞队列）； 每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。]]></content>
      <categories>
        <category>操作系统原理</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理（二）之中断、异常和系统调用]]></title>
    <url>%2F2018%2F09%2F03%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[OS与设备和程序交互类型系统调用、异常、中断 系统调用（来源于应用程序） :应用程序主动向操作系统发出服务请求 异常（来源于应用程序）非法指令或其他坏的处理状态（如内存出错） 中断（来源于外设）来自不同的硬件设备的计时器和网络的中断 三者区别与联系 类型 源头 处理时间 响应 中断 外设 异步 持续，对用户应用程序是透明的 异常 应用程序意想不到的行为 同步 杀死或重新执行意想不到的应用程序指令 系统调用 应用程序请求提供服务 同步或异步 等待和持续 中断、异常和系统调用OS的处理过程中断（软+硬件）1 硬件部分：设置中断标记（CPU初始化） 将内部、外部事件设置中断标记 中断事件的ID 2 软件部分 保存当前处理状态 中断服务程序处理 清除中断标记 恢复之前保存的状态 异常：异常编号 保存现场 异常处理 杀死产生了异常的程序 重新执行异常指令 恢复现场 系统调用程序访问主要是通过高层次的API接口而不是直接进行系统调用 跨越操作系统边界的开销定义在执行时间上的开销超过程序调用开销包括： 建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销 建立内核堆栈 验证参数 内核态映射到用户态的地址空间，更新页面映射权限 内核态独立地址空间，TLB]]></content>
      <categories>
        <category>操作系统原理</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理（一）之操作系统启动顺序]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[操作系统启动顺序参考文章：浅谈操作系统启动过程 1、POST（加电自检）：寻找显卡和执行BIOS机器启动的时执行第一条指令去执行BIOS，将控制权交给BIOS根据CS 和 IP的值就可以找到指令的物理地址0xFFFF:0x0000，也就是0xFFFF0，找到BIOS地址2、BIOS硬件质检然后进行内存寻址：将引导扇区中的Boot.exe，然后加载并跳转到Loader.exe的0x7C00地址（作用：加载内核文件）3、进入操作系统 基础知识设备I/O地址与IRQ中断信道设备I/O地址：设备的门牌号，用于设备组件间的交互通信。不能有两个设备使用相同的地址IRQ中断信道：各设备可通过IRQ来告知CPU该设备的工作情况，以方便CPU进行工作分配任务。（sharing IRQ 中断共享技术） CMOS 与 BIOSCMOS记录主板上面的重要参数 包括系统时间、CPU电压与频率、各设备的I/O地址和IRQ等BIOS 写入主板上某一块闪存或EEPROM的程序，具有断电不易失性，其具有固定的设备地址，开机时执行，加载CMOS当中的参数，并尝试调用存储设别中的引导程序bootloader。 负责开机的硬件自检与初始化以及将bootloader加载到内存中的0x7c00，然后跳转到0x7c00执行。 BIOS地址由CS:IP=16*CS+IP(代码段寄存器:指令指针)来表示。 Bootloader硬盘中的第一个扇区也叫主引导扇区，一个扇区是512字节，所以bootloader也是512字节。其中有400+个字节是启动代码(CS)，负责完成bootloader需要完成的工作，剩下的字节是记录硬盘分区表。 寻址机制寻址是由段寄存器以及指令指针共同完成。段寄存器： CS： code segment，代码段寄存器 DS：data segment，数据段寄存器 ES：extra segment，附加段寄存器 SS：stack segment，堆栈寄存器 指令寄存器IP(instruction pointer)，即是我们熟悉的程序计数器PC。一个地址由段寄存器:指令指针=16*段寄存器+指令指针来表示因为实模式只有20位寻址，所以最大可调用的空间只有1M]]></content>
      <categories>
        <category>操作系统原理</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理（序）]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%EF%BC%88%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[定义 用户角度上，操作系统是一个控制软件 管理应用程序、杀死应用程序 为应用程序提供API服务接口 管理各种硬件资源，例如U盘、网盘、键盘等 对内部管理而言 管理外设（程序与硬件的衔接） 管理分配资源（CPU、内存等程序共享资源，程序调度） 全局内容基本概念及原理 中断及系统调用 内存管理 进程及线程 调度 同步 文件系统 I/O子系统 操作系统的层次架构-“硬件之上，应用程序之下”是连接硬件和软件的中间桥梁，它由机器指令和广义指令组成。 （1）机器指令：指的是CPU能够直接识别并执行的指令。 （2）广义指令：是指系统定义和解释的软件指令。 kernel－操作系统内部组件，包括： CPU调度器 物理内存管理 虚拟内存管理 文件系统管理 中断处理与设备驱动 OS kernel 的特征 并发：一段时间内，有多个程序可以同时运行，需要OS管理和调度 并行：一个时间点，（多个CPU） 共享：分时访问，互斥共享 虚拟：利用多道程序设计技术，让每个用户觉得有一个计算机为他服务 异步： 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，但是只要运行环境相同，OS需要保证程序运行的结果相同。 操作系统的历史 早期计算机使用纸带传输程序和数据，OS只起到加载作用 CPU等硬件快速发展，计算机速度得到提升，性能为得到充分利用，成批／离线处理 内存的容量越来越大，CPU执行多个程序，多道程序设计 为了更好的利用计算机资源，并且更好的和用户交互，出现了分时系统。分时调度 网络的快速发展，出现了分布式的OS。松、紧耦合系统]]></content>
      <categories>
        <category>操作系统原理</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages +Hexo搭建个人博客]]></title>
    <url>%2F2018%2F08%2F13%2FGithub%20Pages%20%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[环境准备（以本教程为例） win10专业版 Git 2.14.3Windows.1 Node.js 10.8.0.0 sublime编辑器 注意：在Windows下安装完成后，git如果是在之前就安装好的，需重启才能使用npm命令 Git安装选项解释见：https://blog.csdn.net/ainuser/article/details/77609180 环境部署-在GitHub上创建Github Pages项目 注册Github创建新仓库点击“New”新建 “Repository”，这里一定要命名为“username.github.io”，然后选择Public，公开是免费的。Github会识别并自动将该仓库设为Github Pages。用户主页是唯一的，填其他名称只会被当成普通项目。 关联Git与GitHub1）准备SSH Key：1234567ls -al ~/.ssh #根目录下检查本地是否本身存在SSH keyrm -rf ~/.ssh #若原本存在，则清除本地原有的SSH key或者在后面生成SSH key的时候对原ssh进行覆盖操作git config --global user.name &quot;&lt;your_name&gt;&quot; #设置Git登录的用户名，与github账户无关，做好记录git config --global user.email &quot;&lt;your_email&gt;&quot; #设置Git登录的邮箱，与github账户无关，做好记录ssh-keygen -t ras -C &quot;&lt;your_github_email&gt;&quot; #生成SSHkey，按照提示Enter，可不设置密码，设置密码后每当执行push操作时都需要输入密码，此处不设置，直接生成即可ls -al ~/.ssh #查看生成的SSH key文件：id_rsa、id_rsa.pubcat ~/.ssh/id_rsa.pub #查看SSH key 2）添加SSH key：Personal Setting &gt; SSH and GPG keys&gt;New SSH keyTitle：随意即可Key：按照提示复制，将准备好的SSH key全部复制粘贴过来 3）SSH key测试连接12345$ ssh git@github.com #根目录下运行命令即可，不需要修改该命令的参数 #如果设置了密码会出现这一行：Enter passphrase for key &apos;/c/Users/llp/.ssh/id_rsa&apos;:PTY allocation request failed on channel 0Hi llplmlyd! You&apos;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed.#这里表示已经连接成功 Hexo建站 Hexo安装1$ npm install -g hexo-cli #根目录下运行即可 本地新建博客站点文件夹&lt;your_blog_name&gt;初始化建站123cd &lt;your_blog_name&gt; #进入站点文件夹，tips：可以直接在站点文件夹下右键Gitbash即由git进入了文件夹内hexo init #在当前目录下初始化，注意一定要是空文件夹，否则会报错，无法初始化npm install #开始初始化安装hexo各配置文件 初始化结果如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 有时候会有一些其他的文件如：package-lock.json等 配置_config.yml配置文件修改可以借助编辑器进行修改，主要修改以下几个字段 #Site123456 #Sitetitle #博客标题subtitle #博客副标题description #博客描述author #作者language 按照所选择主题进行设置，此处先默认处理 #Directory123#Directory#如果是站点即博客文件夹，则采取默认配置即可；如果是其他站点下的子文件夹则须修改#参考https://hexo.io/zh-cn/docs/configuration ## Themes12## Themes: https://hexo.io/themes/theme: next #主题根据自己使用的主题所在的文件夹名字修改 # Deployment123456# Deployment 部署Hexo与Github关联推送## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: ssh://git@github.com/[githubname]/[库名].github.io branch: master # Search12345678# 手动添加本地搜索功能字段# Search# Local Search: http://theme-next.iissnan.comsearch: path: search.xml field: post format: html limit: 10000 主题选择与配置1）在hexo上下载解压喜欢的主题到本地https://hexo.io/themes/2）复制该主题文件夹到：站点文件夹/themes3）修改 _config.yml 中的## Themes4）验证是否启用1234$ hexo new [layout] &lt;title&gt; #在站点根目录下gitbash输入，layout可不填，默认为post$ hexo s --debugINFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.#选中地址右键实时预览 5）主题配置文件修改http://theme-next.iissnan.com/① 主题 Scheme设定 &gt; 设置 语言(站点配置文件中修改)② Menu 菜单设置12345678# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu:home: / || home #首页about: /about/ || user #关于tags: /tags/ || tags #标签categories: /categories/ || th #目录archives: /archives/ || archive #归档 ③ Sidebar 侧栏设置：默认④ Avatar 头像设置123456# 将使用的头像图片调整成正方形并置入#[站点文件夹]\themes\next\source\images# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/your_avatar.jpg #文件名与后缀需完全对应 ⑤ Social Links 添加社交连接123# Social Links.social: Google: https://plus.google.com/yourname || google ⑥ links 友情链接12links: 中文: 网址链接 ⑦添加评论功能1234567# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: your appid appkey: appkey ⑧添加阅读量统计、评论量统计本文采用leancloud第三方插件http://theme-next.iissnan.com/getting-started.html#leanclound-page-views注册leancloud获得AppleID 和AppleKey并在leancloud上添加两类class：Counter和Commentshttps://leancloud.cn/在主题配置文件中设置AppleID 和AppleKey， ⑨ 添加 访问量统计12345678910111213141516# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt; 访客数&lt;/i&gt; site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt; 总访问量&lt;/i&gt; site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt; 总阅读量&lt;/i&gt; page_pv_footer: 次 ⑩ 添加标签http://theme-next.iissnan.com/theme-settings.html#tags-page 6）新建目录博客中的关于、标签和分类等栏目无文件夹，需要个人手动创建1hexo new page categories [栏目英文名称] 注意：要添加标签和自己新建目录之后侧栏才会显示出该数量 生成与部署到Github上在站点目录下右键gitbash 12345$ hexo s --debug #可在各项详细配置完成后先进行测试INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.$ hexo clean #可以清除缓存，再进行测试$ hexo generate #简写为hexo g，生成静态文件，文件位于public文件夹中$ hexo deploy #简写为hexo d，部署网站到Github上，#可以生成与部署联用 hexo g -d 表示生成后立刻部署到github上 注意：这里不需要使用到Git 与remote的同步与push命令之类的，请不要强行push站点文件夹，使用hexo d只会将public文件夹与仓库同步，配置文件仍保留在本地。 参考链接：https://hexo.io/zh-cn/docs/http://theme-next.iissnan.com/http://theme-next.iissnan.com/third-party-services.html]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维基础(一)]]></title>
    <url>%2F2018%2F08%2F09%2FLinux%E5%AE%89%E5%85%A8%E8%BF%90%E7%BB%B4%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1 虚拟机的使用创建虚拟机磁盘：虚拟机中文件形式存在（镜像文件）ifconfig 查看设置网络配置：vnet8，桥接模式vnet1：仅宿主机模式 2 操作系统概念内存，寻址空间，平面寻址，三维寻址linux版本号(内核版本号):三部分组成: A.B.CA:主版本号B:次版本号(奇数:开发版本 偶数:发行版本)C:修订版本号(修订次数) 内核版本:3.6.28 3时主版本号 6:次版本号 28:修订了28次先把3.6.28拷贝一份进行研发,并把版本号升级为3.7.01(在3.6.28基础上修复漏洞,开发新功能)3.8.XX:下一个发行版本开发–内测(修复漏洞,开发新功能)–公测–正式版本生成(正式上线) ~当前用户所在目录：代表用户宿主目录 3 Linux设计哲学思想123456789101112131415161718192021222324252627shell：使用者与计算机交互的接口，人输入命令给shell，shell传递给内核 Linux支持的shell：bash：默认使用的shell ksh cshxshell：远程连接linux 还有CRT 其使用方法：在同一个网段中，然后即可使用Xshell软件：ssh ``` IP→输入用户名，密码内核作用：无论从图形界面/还是字符界面 都可以返回结果。1、进程管理：要执行的任务；2、内存管理；3、文件系统：存储设备上村塾数据的方式方法Linux ext3/4/，xfs等；4、网络功能：管理IP地址信息等；5、硬件驱动；6、安全功能；### Linux设计思想1:有很多的小程序组成,每个小程序完成单一的功能,实现复杂的任务(http服务需要安装很多小组件)2:一切皆文件:所有的外围设备(硬件)或者其他程序3:尽量避免捕获用户接口4:配置文件保存为纯文本格式(可以用文本编辑器编辑 vim)### Linux终端:多用户多任务系统6个终端:ctrl+alt+F1-F6切换图形界面:ctrl+alt+F7切换用户:su(switch user)su命令:当root用户切换到普通用户时,不需要普通用户的密码;而当普通用户切换到root用户时,需要提供root用户密码root student```shell# su user_name$ exit 退出当前用户 命令格式命令字 [选项] [参数]:中括号表示可以省略，例如 ls -a /ect/命令字:唯一的,实现某一项功能选项:修改命令的执行方式(实现特定功能)长选项:–引导,是一个单词(多个长选项不能组合)短选项:-引导,是一个字符(多个短选项可以组合)参数:命令作用的对象 4 高效获取命令帮助信息Linux命令分类内部命令:shell自带的命令外部命令:在Linux文件系统中存在一个应用程序 type:查看Linux命令类型12[command] is a shell builtin:buildin关键字说明该命令是内部命令mkdir is /bin/mkdir:有路径显示(外部命令) 路径绝对路径:从根(/)开始的路径是绝对路径,linux系统中只有一个根相对路径:以所处的工作目录为参照点 (.代表当前路径 ..代表上一级路径 ~代表登录用户的宿主目录) ls(list):列出目录-l(–long):以长格式显示1-rw-------. 1 root root 1207 Nov 6 18:51 anaconda-ks.cfg 12345678910111213141516171819202122第一位:文件类型 -:代表普通文件(file) d:代表目录(directory) b:块设备(block):如硬盘,U盘等 c:字符设备(char):如键盘等 :套接字文件(socket) p:命名管道(pipe) l:符号链接文件(symbolic link file )第二到十位:权限位(rwx:读写执行) 234位:文件属主权限(owner) 567位:文件属组权限(group) 8910位:其他用户权限(other)1: 代表文件硬链接的次数第一个root:代表文件属主(owner)第二个root:代表文件属组(group)1207:文件的大小Nov 6 18:51:文件最后被访问的时间戳(stat命令查看文件时间戳)文件的时间戳: access:访问的时间戳 Modify:文件被修改时间戳(修改文件数据:添加删除数据等) change:文件被更改时间戳(更改文件属性) anaconda-ks.cfg:文件名 ls命令字所带选项用法123456789-h:为文件大小添加单位，可以与ls -l联用，即ls -lh-a:显示目录下所有文件(包括. .. 以.开始的隐藏文件)-A:和-a相同,但是不显示.和..-R:递归显示目录中的内容(一并显示子目录中所有内容)-r:逆序显示目录内容-i:显示文件所在的inode节点(index node)-d:显示目录本身的属性递归显示-R：Recrusion逆序显示文件内容：-r：reverse 环境变量:内存中的命名空间PATH变量:存放系统命令路径,以冒号隔开查看PATH变量:echo $PATH(Linux命令严格区分大小写)存在的路径12[root@www ~]# echo $PATH/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin 如果在以上路径中没有找到相关命令(该命令为外部命令),提示用户command not found如果一个命令在以上多个路径中存在,系统会按照从前往后的顺序查找,查找到该命令后,后面的路径的不在查找 hash:查看命令缓存及命中率 Linux命令的帮助信息内部命令:help [command] 外部命令:[command] --help man:帮助(命令的使用说明书)(查看内部命令时,显示的是bash帮助信息) 语法: man [command] 上下方向键:翻行enter:向下翻行pagedown:向下翻页pageup:向上翻页/word:从上往下查找关键字?word:从下往上查找关键字q:退出当前帮助信息 man目录说明1:User Commands:普通用户命令(/bin /usr/bin /usr/local/bin):binary二进制2:System Calls:系统调用库3:C Library Functions:库调用4:Devices and Special Files:设备或特殊文件(硬件设备)(硬件设备存放在/dev)5:File Formats and Conventions:查看配置文件格式6:Games et. Al.:游戏7:Miscellanea:杂项8:System Administration tools and Deamons:管理命令(/sbin /usr/sbin /usr/local/sbin)sbin:secret binary which:查看命令所在的路径whatis:查看命令所在的帮助信息目录,该命令在系统启动大约70分钟后会生成whatis的数据库,如果时间太短,该命令不会执行。使用makewhatis(CentOS 6)初始化该命令,就不需要等待在CentOS 7中使用man的命令1yum -y install man-pages man使用说明12345678910NAME:命令名称及简要用法SYNOPSIS:语法格式,可能包括一些选项的使用 如：ls -[Option]DESCRIPTION:命令和命令选项的详细说明Exit status:退出状态码AUTHOR:作者信息REPORTING BUGS(BUG):发现BUG时如何反馈信息COPYRIGHT:该命令的版权信息SEE ALSO:另外参照的帮助信息OPTIONS:说明该命令每一个选项的详细用法EXAMPLES:命令使用实例 man手册页目录123456/usr/share/doc(工作中主要是查看内核信息)&lt;&gt;:必须使用的选项或参数,不可以省略[]:可是省略的选项或参数...:可以使用多个选项或参数|:代表多选一&#123;&#125;:分组,没有特殊意义 一些常用命令info:在线查看帮助,注重于命令历,版史权信息等cd:change directory(切换目录) cd:不加选项,返回到当前用户的宿主目录 -:返回到上一次的工作路径 ~username:切换到username的宿主目录pwd:print working directory:显示当前所处的工作目录 5 Linux根文件系统 Linux目录结构是一个倒树形的：最上面的是根，Linux只有一个根；Windows有多个根。而Linux的系统类型又多（发行产商较多），为统一每个系统下的文件目录，产生了一个标准，即FHS标准：希望用户可以了解已经安装的系统 FHS标准文件系统分层结构标准（File System Hierarchy Standard）FHS规定:/etc /bin /dev /lib /sbin五个目录必须要和根目录位于同一文件系统https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standardhttps://linux.cn/article-6132-1.html 根目录下目录及子目录的作用根文件文件系统123456789101112131415161718192021222324252627282930313233343536(/):rootfs:root filesystem，主层次根/bin: 单用户二进制命令文件,存放命令/boot: 引导加载驱动，存放启动和内核相关文件/dev: 存放设备文件/etc: 存放应用程序的配置文件 /etc/ resolv.conf DNS配置地址 /etc/hosts Hosts信息 /etc/sysconfig 网络配置/home:普通用户的家目录,默认为/home/USERNAME/lib和/lib64:存放系统开机时需要用的函数库及/bin和/sbin命令调用函数库/lib/modules:存放内核相关的模块(驱动程序等)/media和/mnt:挂载点,/media挂载移动设备 /mnt挂载临时设备/opt:第三方软件存放目录(用户自行安装的软件存放处),现在一般安装到/usr/local下/proc:伪文件系统,数据存放在内存中,存放关于进程的相关信息，有CPU、内核的信息，系统调优的时候可以在此目录进行修改配置，/root:管理员的家目录/sbin:存放管理员使用的命令，只有管理员可执行/srv:service缩写,存放服务数据目录,如可以把www服务的网页存放到该目录/tmp:存放临时文件,所有用户都可以访问创建文件,但是每个用户只能删除自己的文件；一定时间后系统会删除/sys:伪文件系统,存放在内存中,记录内核相关的信息,包括目前加载内核模块和内核检测到的硬件设备等/usr:UNIX software resource:存放安装的应用程序 /usr/bin:普通用户使用的命令(和/bin区别是否与开机有关) /usr/sbin: 网络服务器命令 /usr/lib和/usr/lib64: 包含各种应用程序函数库 /usr/share:存放共享文件目录(在线帮助文件,杂项,时区文件等) /usr/include:存放头文件，比如C语言的头文件，安装软件的头文件 /usr/src:释放源代码目录/var: vary缩写,存放经常变动的文件,比如 志,mail等， 持续改变的各种文件存放位置 包括cache、mail、lock、log、mail、spool /var/cache:存放应用程序运行时产生的缓存文件 /var/lib:程序运行时,需要使用的数据文件的存放目录，比如MySQL的文件即可能放在这里 /var/lock:设备或资源一次只能被一个应用程序使用,如果多应用程序会产生错误,因为要为设备或资源上锁(存放锁文件) /var/log:存放日志目录(系统,用户登录,服务日志等) /var/mail:存放个人电子邮件(系统报警产生邮件信息等) /var/run:存放应用程序运行时PID文件(进程号.pid结尾) /var/spool:存放队列数据,排队等待其他用户程序使用的数据,数据通常使用完成后会被删除./ sgml存放处理标准通用标记语言的配置文件./xml 处理xml的配置文件 /bin、/sbin、/usr/bin三者区别/bin：存放的是系统启动时的二进制指令/usr/bin：与开机无关 The root file system is the file system contained on the same diskpartition on which the root directory is located; it is the filesystemon top of which all other file systems are mounted as the system bootsup. 根文件系统是包含在根目录所在的同一磁盘分区上的文件系统; 它是文件系统，在系统启动时安装所有其他文件系统。 file命令:查看linux中文件类型语法: file [options] file_name Linux文件名限制1:单个文件或目录的名称不能超过255字符2:文件命中不能包含特殊字符(/ . - +等) Linux文件类型123456789101112-:普通文件纯文本文件(ASCII):配置文件二进制文件(binary file): 命令数据格式文件(data):/var/log/wtmpd:目录文件l:链接文件:软链接文件设备文件:(/dev)b:block块设备c:character字符集设备:一次性读取,按顺序读取s:socket套接字文件:通常用在网络上数据连接: IP:PORTp:管道:特殊的文件类型,解决多个程序同时访问一个文件所造成的错误问题在Linux一个文件是否能被执行，和后缀扩展名没有很大关系，所以需要用到file来使用 6 Linux 常见命令12Vim：vi 编辑创建文件，insert键入编辑文本，ESC退出编辑，":wq",write and quit，如果不想保存就直接 q就可以了cat &#123;abc.txt，def.txt，...&#125; /... 在...目录下同时创建几个...文件 基本命令:ls cd pwd学习内容:file cat cp mv rm mkdir touch tree which whereis文件管理；目录管理；系统管理；网络管理等 file1234567语法:file [options] [args]:查看文件类型(windows是用扩展名识别文件类型)-b:显示结果时,不显示文件名-c:显示执行file命令的执行过程(file是如何去判断文件类型),便于排错或分析file命令执行过程-i:输出MIME类型的字符串-z:显示压缩文件的内容-L:查看软链接对应文件的类型-f:查看文件中文件名的类型 查看文本文件内容命令:cat more less head tailLinux和Windows中文件内容行尾标记是不同的:Linux中是以$为结尾Windows中是以ENTER键结尾 cat12345678910111213141:一次性查看整个文件 语法:cat [options] [args]2:从键盘输入创建一个新文件或向现有文件中添加新数据: 新建新文件:cat &gt;new_file_name &lt;&lt;EOF //EOF:end of file&gt;Linux command //从键盘输入&gt;Uinx command //从键盘输入&gt;EOF //从键盘输入,以结束书写向现有文件中追加数据:cat &gt;&gt; file_name &lt;&lt; EOF&gt;CISP!&gt;CISSP!&gt;EOF3:把多个文件内容合并到一个文件输出:cat file1 file2 &gt; file3 cat /etc/passwd /etc/shadow &gt; /root/user.txt1234-n:显示文件内容时同时显示行号,包括空行-b:和-n功能相同,但不包括空行-S:当文件中有多个空行时,合并为一个空行-E:在显示内容时,结尾添加$符号 more可以翻页查看文本文件内容enter键:向下翻一行空格键:向下翻一屏ctrl+b:向上翻一屏ctrl+f:向下翻一屏=:显示当前的行号v:调用vi编辑器!command:调用shell执行命令q:退出more命令 more +num file_name //从num行开始查看文件内容 less可以翻页查看文本文件内容enter键:向下翻一行空格键:向下翻一屏pagedown:向下翻一屏pageup:向上翻一屏上下方向键:向上/向下翻一行/word:在该文件中查找word关键字n:查找下一个N:查找上一个 管道连接多条命令,前一条命令输出结果作为后一条命令的输入条件, 管道符 | head默认查看文件文件的前十行-n:查看文件文件前n行 tail默认查看文本文件的后十行-n:查看文本文件的后n行-f:动态查看文本文件内容,如动态查看日志: tail -f /var/log/messages在任何位置均可进行查看，当系统有安装/服务启动关闭等行为时，会马上有记录出现 cp复制文件或目录(copy简写)语法:cp [options] [src_file] [des_file]-f:force,强制复制文件或目录不进行提示-r:递归复制目录-s:为某个文件创建符号链接(软链接),而不是复制文件-b:覆盖已有的文件前,对目标文件进行备份-l:为文件创建硬链接,而不是复制文件-p:复制文件时保留文件的原有属性-d:当复制软链接文件时,把目标文件或目录也会创建为软链接,并指向最原始的文件-i:覆盖目标文件前询问(cp = cp -i) mv: move移动或从命名文件和目录(当原位置和目标位置是同一目录时,是重命名;当原位置和目标位置不是同一目录时,是移动)-b:移动前先对源文件进行备份-f:强制覆盖-i:覆盖目标文件前询问-t:将多个文件移动同一个目录(目标目录在前面,后面跟文件 mv -t [directory] file1 file2 …) rm: remove删除文件或目录-d:删除可能存在数据的目录-f:强制删除-i:删除前进行询问-r:递归删除整个目录-v:显示命令执行过程 mkdirmake directory,创建空目录-m:创建目录时同时设置权限-p:递归创建新目录-v:显示创建目录的过程 touch创建新文件或者修改文件时间戳123456-a:只改变访问时间-c:不创建文件-d:使用指定时间戳创建新文件,而不是使用系统时间-t:使用指定格式时间戳创建新文件,而不是使用系统时间-f:解决与BSD系列Unix系统兼容性-m:只更改变动时间 tree:查看目录树(tree = ls -R)yum -y install tree which:查找命令所在的路径1234whereis:查看命令所在的路径,源代码文件,帮助信息文件所在的文件-b:只查看文件所在的位置(等同于which命令)-m:只查看帮助信息所在的位置-s:支持看源代码所在的位置 7 Shell特性安装进程树命令：yum install psmiscpstree 进程树命令 pstree -p ###shell广义分类GUI:包括GNOME KDE XFACE等CLI:sh csh ksh bash等(Linux发行版本中,bash是默认使用的shell程序) shell启动:当用户登录完成后,系统会自动启动shell程序进程:应用程序的副本;使用PID区分(在系统中,一个进程只认为自己存在)root student用户shell:父shell程序和子shell程序(父子shell之间设置环境互相独立,互不影响)123cat /etc/shells //查看当前系统所支持的shell程序yum -y install ksh csh //安装ksh,csh的shell程序exit //退出当前shell程序 shell是一个程序 bash特性命令历史: Linux会自动记录系统过去执行的命令,并保存在内存的缓冲区中，在每个用户的家目录下,有个隐藏文件.bash_history保存命令历史 # history //查看linux的历史 -c:清空命令历史 -d:删除某一条命令历史 -w:将命令历史保存到某个文件中 变量:PATH命令路径变量 HISTSIZE:命令历史大小变量 $ echo $HISTSIZE //查看HISTSIZE变量的值,默认的命令历史是1000条 命令历史使用技巧: !n:执行命令历史中的第n条命令(n是命令历史编号) !-n:执行命令历史中的倒数第n条命令(n是命令历史编号) !word:执行命令历史中最近一次以word开始的命令(word必须能够唯一的标识用户想执行的命令) !!:执行上一条命令 !$:引用一个命令的最后一次参数 ESC键(按完松开) 再按.键:引用一个命令的最后一次参数 命令行编辑：ctrl+a:光标快速跳转到命令行的行首ctrl+e:光标快速跳转到命令行的行尾ctrl+u:快速删除光标位置到命令行行首的字符ctrl+k:快速删除光标位置到命令行行尾的字符ctrl+l:清屏(命令clear:清屏) 命令行展开 双Tab可以显示与关键输入相关的所有命令 当有唯一识别度的时候，单Tab可以显示命令 $(COMMAND) 常用于shell脚本编程 3.1:命令补齐:在PATH变量搜索命令并补齐(PATH变量必须正常,输入要补齐命令的字符数一定能够唯一标识这条命令;tab键补齐) 按tab键两次,列出以某个字符开始的所有的命令 # echo $PATH //查看PATH变量的值 路径和文件补齐:在系统路径中查找 命令行补齐功能不能补齐选项 3.2:命令替换(经常用到shell脚本编程中) $(command)或者 `command`(两边是反撇号) 命令替换就是把命令中的子命令替换成子命令执行结果的过程 # echo &quot;字符串&quot; &quot;&quot;(双引号):弱引用(可是实现变量的替换,把变量名替换为变量值) ``(反撇号):命令引用 &apos;&apos;(单引号):强引用(不能完成变量替换) 例如： [root@localhost ~]# echo &apos;Directory is $(pwd).&apos; Directory is $(pwd). [root@localhost ~]# echo &quot;Directory is $(pwd).&quot; Directory is /root. 单引号和双引号效果不一样，双引号执行命令，单引号不执行。 命令别名(alias定义的别名只在当前shell生效)1234# alias COMM_ALIAS=COMMAND //只执行alias命令,列出系统中所有的命令别名注意:执行alias命令时,COMMAND最好用''(引号)引起来例如：alias cdnet='cd /etc/sysconfig/network-scripts'# unalias COMM_ALIAS //取消命令别名 命令行通配:globbing123456789101112131415与正则表达类似*:匹配任意长度的任意字符?:匹配任意单个字符[]:匹配指定范围内的任意单个字符[ab] [a-m] [a-z] [A-Z] [a-zA-Z] [0-9] [a-zA-Z0-9][^]:匹配指定范围外的任意单个字符[^a-z] [^0-9]使用示例：https://www.cnblogs.com/tdcqma/p/5853020.html[:space:]:表示空格[:punct:]:表示所有标点符号[:lower:]:表示所有小写字母[:upper:]:表示所有大写字母[:alpha:]:表示所有字母(包括大小写)[:digit:]:表示所有数字[:alnum:]:表示所有数字和大小写字母 IO输入输出重定向以及管道计算机体系结构:控制器:CPU,读取系统指令运算器:CPU,运算存储器:RAM(内部存储器:易失性存储器)输入设备(Input):输入数据,如键盘,硬盘等输出设备(Output):显示指令执行结果,如显示器,音响,硬盘等 计算机总线bus地址总线:负责内存寻址数据总线:负责传输数据控制总线:负责控制指令寄存器:CPU中内部临时存储空间 I/O设备:负责计算机内部存储设备和外部存储设备(如硬盘,光盘,U盘等)进行交互的设备 程序:指令+数据指令:有程序提供,负责加工数据数据:系统中数据可以有多种来源,比如来自变量,来自文件,来自输入设备等 系统默认数据来源当用户没有为指令指定数据来源时,系统要有默认的数据来源： 标准输入输出设备: 标准输入设备:键盘(stdin),文件描述符为0 标准输出设备:显示器(stdout),文件描述符为1 标准错误输出设备:显示器(stderr),文件描述符为2三种数据流: 标准输入数据流/标准输出数据流/标准错误输出数据流 当在Liunx中打开一个文件时,内核会反复调用,对于文件标识就很重要了,用文件描述符来标识文件,文件加载完成用数字标识fd:file descriptor(文件描述符) IO重定向把默认输入输出数据来源,重新定向到其他的文件或设备1234567891 输出重定向: &gt;:覆盖输出重定向 &gt;&gt;:追加输出重定向 2&gt;:错误覆盖输出重定向 2&gt;&gt;:错误追加输出重定向 &amp;&gt;:混合覆盖输出重定向 &amp;&gt;&gt;:混合追加输出重定向2 输入重定向: &lt;:输入重定向 管道:连接多条命令,把前一条命令的输出结果作为后一条命令的输入条件(组合小程序,实现大功能) command1 | command2 | commad3 .... tr:实现字符转换,不修改源文件,语法:tr [OPTION]… SET1 [SET2]例如：cat 文件 | tr &#39;a-z&#39; &#39;A-Z&#39;tee: 将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的stdinhttp://man.linuxde.net/tee变量编程 8 用户&ensp;&ensp;&ensp;&ensp;Linux实现权限隔离机制(多用户)，用多用户分组实现。操作系统使用UID来识别用户，而如果同一个文件多个用户都有相同权限时，启用组GID。操作系统识别用户:&ensp;&ensp;&ensp;&ensp;用户:UID（管理员用户0；普通用户1000-65535；程序/系统用户1-999）&ensp;&ensp;&ensp;&ensp;组:GID(逻辑容器:包含用户;实现多个用户对于某个文件或应用程序分配相同的权限)组分类：管理员组/普通组&ensp;&ensp;&ensp;&ensp;基本组:Linux中,新建用户时,没有指定隶属于的组,系统会为该用户建立一个同名组,作为该用户基本组&ensp;&ensp;&ensp;&ensp;附加组:方便以后为用户分配文件/程序权限 process(进程):用户执行应用程序的过程，Ngix用户、MySQL用户，不允许登录到操作系统，只是作为系统用户来运行某个程序。 /etc/passwd解释用冒号隔开：name:password:UID:GID:GECOS:directory:shell第一列:用户的登录名第二列:加密密码(x表示密码占位符,密码保存在/etc/shadow中)第三列:用户的ID号第四列:组的ID号第五列:用户的描述信息第六列:用户宿主目录第七列:用户默认使用的shell(/etc/shells) /etc/shadow解释第一列:用户的登录名第二列:用户加密后的密码第三列:最后一次更改密码时间(从1970年1月1号)第四列:密码最小使用时间第五列:密码最长使用时间 /etc/shadow密码区域解释(格式:$id$salt$encrypted):1234567三部分组成:用$隔开 第一部分加密算法: 1:MD5加密 5:SHA-256加密 6:SHA-512加密 第二部分:随机序列号 第三部分:随机序列号和密码共同加密后的字符串 加密算法12345678对称加密:加密和解密使用相同的密码(效率高)非对称加密:加密和解密使用不同的秘钥,公钥和私钥单向加密,散列加密:提取数据的特征码,常用于数据完整性校验 1:不可逆 2:定长输出 md5: 128位定长输出 sha: 160位 224位 256 位 384位 512位 3:雪崩效应:输入数据一小点儿的变化,会引起结果的巨大变化 例：123456789101112131415[root@localhost ~]# cat /etc/default/useradd# useradd defaults fileGROUP=100 //可以创建普通组HOME=/home //普通用户宿主目录位置(在/home下生成和用户同名的目录,作为用户的宿主目录)INACTIVE=-1 //是否启用户过期停止使用权,-1代表不启用，如果是2则，是过期后两天停止使用权EXPIRE= //设定过期时间,格式为20170501SHELL=/bin/bash //设定用户的默认使用shellSKEL=/etc/skel //新用户宿主目录模板目录CREATE_MAIL_SPOOL=yes //是否为用户启用邮件通知功能 SKEL=/etc/skel //新用户宿主目录模板目录（隐藏文件）：[root@localhost ~]# ls -a /etc/skel. .. .bash_logout .bash_profile .bashrc[root@localhost ~]# ls -a /home/jerry/. .. .bash_logout .bash_profile .bashrc etc/skel:目录解释(用户宿主目录模板目录,只对新建用户生效).bash_logout:用户注销时执行的命令.bash_profile:用户登录系统时执行的命令(用户变量).bashrc:用户登录一个新shell时执行的命令 etc/login.defs文件解释(只对新建用户生效，修改后对以前的用户不会产生影响)MAIL_DIR /var/spool/mail //用户系统邮件存放目录PASS_MAX_DAYS 99999 //密码最长使用期限PASS_MIN_DAYS 0 //最短使用期限,0代表不受限制PASS_MIN_LEN 5 //密码最小长度，5代表5个字符PASS_WARN_AGE 7 //密码过期前的警告时间，UID_MIN 1000 //最小UID号UID_MAX 60000 //最大UID号SYS_UID_MIN 201 //系统用户最小UIDSYS_UID_MAX 999 //系统用户最大UIDGID_MIN 1000 //普通组最小GIDGID_MAX 60000 //普通组最大GIDSYS_GID_MIN 201 //系统组最小GIDSYS_GID_MAX 999 //系统组最大GIDCREATE_HOME yes //是否创建宿主目录UMASK 077 //关于权限反掩码USERGROUPS_ENAB yes //删除用户时是否删除组ENCRYPT_METHOD SHA512 //用户密码的加密方式 9 用户管理命令用户管理:USERADDuseradd, userdel, usermod, passwd, chsh, chfn, finger, id, chage123456# yum -y install vim make cmake man man-pages mlocate sysstat net-tools# yum -y groupinstall &quot;Development tools&quot;# mandb //生成whatis数据库# updatedb //生成locate数据库# vim /etc/selinux/configSELINUX=disabled useradd:添加新用户1234567891011121314151617181920(更改/etc/passwd /etc/shadow /etc/group) useradd [options] user_name -c:为用户添加描述信息 -d:指定用户的宿主目录(默认宿主目录在/home目录) useradd -d /.../用户名 用户名 -D:查看和改变默认的值(修改/etc/default/useradd文件中的选项和值) -g:修改组 -b:修改宿主目录 -f:修改过期是否停用 -e:修改过期 时间 -s:修改默认shell -e:新建用户时,设置用户默认的过期时间,时间格式为:YYYY-MM-DD -g:指定用户的基本组(没有该选项,Linux新建用户时,会新建一个同名组作为用户的基本组) -G:新建用户时指定用户的附加组,附加组可以有多个,用逗号隔开 -m:创建宿主目录,和-k一起使用 -M:创建用户时,不为用户创建宿主目录 -p:创建用户时,为用户设置加密的密码(不推荐使用) -r:创建系统用户(不创建宿主目录,UID和GID使用系统用户ID) -s:指定默认的shell(系统支持的shell) -u:指定用户的UID passwd:为用户设置密码/锁定解锁用户/查看状态1234567891011121314语法:passwd [options] user_name root用户可以为普通用户设置密码 -l:锁定用户(暂时无法登陆系统) -u:解锁用户 -S(大写):查看用户状态,显示/etc/shadow文件中各个字段的内容 （LK、PS） --stdin:标准输入,经常用在shell脚本编程中为用户自动设置密码 如： echo “123” | passwd -- stdin tom（用户名） -d:删除用户密码（root用户）,允许普通用户以空密码登录(不建议使用) -e:设置用户密码过期,用户再次登录时,需要修改密码 -n:设置密码最小使用期限,修改/etc/shadow中第四列 -x:设置密码最大使用期限,修改/etc/shadow中第五列 -w:设置密码过期前的警告时间,修改/etc/shadow第六列 -i:修改过期后的宽限时间,修改/etc/shadow第七列锁定密码：多了两个感叹号 普通用户设置密码时,先验证当前密码,符合密码策略root用户设置密码时,不需要验证当前密码,并且也可以不要求符合密码策略 /etc/shadow:保存用户密码相关信息的文件第一列:用户登录名第二列:加密密码($id$salt$encrypted password)第三列:最后一次更改密码时间第四列:密码最小使用时间(用户无法更改密码)第五列:密码最大使用期限(用户必须更改密码的时间)第六列:密码过期前的警告时间第七列:密码过期后一个宽限时间第八列:密码失效时间第九列:保留 userdel:删除用户123(修改/etc/passwd /etc/shadow /etc/group文件)语法:userdel [options] user_name-r:删除用户时,连同删除用户的宿主目录 usermod:修改用户属性(修改/etc/passwd中内容)很多命令与useradd相似语法:usermod [options] user_name-c:更改用户的描述信息-d:更改用户的宿主目录-e:更改用户的过期时间,格式YYYY-MM-DD-f:修改/etc/shadow第七列内容-g:修改用户的基本组-G:修改用户的附加组-l:修改用户的登录名-s:修改用户的shell(系统支持的shell程序)-L(大写):锁定用户-U(大写):解锁用户 chsh:修改用户的shell语法:chsh [options] user_name-s:后面跟shell,更改用户的shell-l:显示当前系统支持的shell(/etc/shells) finger:显示用户的基本信息finger [options] user_name chfn:修改用户的基本信息语法:chfn [options] user_name-o:修改办公室-p:修改办公室电话号码-h:修改家庭电话号码-f:修改用户名 id:显示用户和组的ID语法:id [options] user_name-a:忽略其他版本区别-Z(大写):显示安全上下文内容(selinux)-g:显示有效组的ID-G:显示所有组的ID-n:不显示组号,显示名字-u:显示用户ID chage:修改用户密码的时间信息(/etc/shadow)语法:chage [options] user_name-l:列出用户的详细的密码参数-d:修改/etc/shadow第三列内容,后面跟日期,格式YYYY-MM-DD-E:修改/etc/shadow第八列内容,后面跟日期,格式YYYY-MM-DD-I:修改/etc/shadow第七列内容,后面跟天数-m:修改/etc/shadow第四列内容,后面跟天数-M:修改/etc/shadow第五列内容,后面跟天数-W:修改/etc/shadow第六列内容,后面跟天数 用户组管理groupadd, groupdel, groupmod, gpasswd,newgrp,groupmems1234[root@localhost ~]# cat /etc/grouproot:x:0:bin:x:1:daemon:x:2: /etc/group:信息解释第一列:组的名字 第二列:组的密码区域 第三列:组的ID号(GID) 第四列:组中的成员（初始化成员不显示） 1234[root@localhost ~]# cat /etc/gshadowroot:::bin:::daemon::: /etc/gshadow:第一列:组的名字第二列:组的密码第三列:组的管理员第四列:组成员列表 groupadd-d:创建组时指定组的ID-r:添加一个系统组 groupdel:删除一个组默认情况下,不能删除一个用户的基本组,可以通过修改用户的基本组后删除该组userdel -r 可以删除用户的同时,系统会删除同名基本组(该组是一个用户的基本组) groupmod:修改组的属性-g:修改组的GID号-n:为组重命名 gpasswd:为组设置密码,设置组的管理员,添加组成员-A:为组设置管理员 Administrator-M:把一些用户添加组中,用逗号隔开(普通用户)-r:为组移除密码-R:让组的密码失效-a:为组添加成员(组的管理员操作命令)-d:删除组成员(组的管理员操作命令) newgrp:为用户修改有效组(只在当前shell生效)exit:退出newgrp groupmems:为组添加成员,显示组成员列表 10 Linux权限文件r(read):读权限,可以查看文件的内容,使用cat more等命令w(write):写权限,可以修改文件的内容及删除文件x(execute):执行权限,可执行文件或脚本 目录r:读权限,可以查看目录中的列表,执行ls命令w:写权限,可以向目录中新建文件或目录等x:执行权限,可以执行cd命令 权限用数字表示r:4w:2x:1—:000 0rwx:111 chown:change owner改变文件属主和属组-R:递归更改目录的属主或属组 --reference:复制一个目录的权限属性到目标文件 chown:修改文件属组时,在组名前添加点符号(.)或冒号(:) 同时修改属主和属组:chown username.groupname filename chgrp:change group修改文件属组chmod:修改文件或目录权限语法:chmod [augo][+-=][rwx] file_name-R:递归更改文件或目录的权限 a:所有用户u:文件属主g:文件属组o:其他用户 +:为用户添加权限-:为用户减少权限=:为用户赋予权限例如：chown a+x a 默认情况下,为了安全,Linux系统新建文件时不添加执行权限新建文本文件时候的权限一般为644新建目录时候，执行cd命令：755 umask:反掩码(在/etc/login.defs中定义)rwx:7文件:rw-rw-rw-:666 644=rw-r–r–目录:rwxrwxrwx:777 755=rwxr-xr-x新建文件时,权限掩码(666)减去反掩码(022)就是新建文件的权限(644)新建目录时,权限掩码(777)减去反掩码(022)就是新建目录的权限(755)掩码发生变化权限也会发生变化 Linux隐藏权限chattr:修改文件的隐藏权限/ /dev/ /tmp /var/ /etc/目录不受chattr保护语法: chattr +-= [options] file_name a:只能向文件中追加数据,不能删除 Append onlychattr +a 文件名，echo “…”&gt;&gt;…文件名 i:任何用户不能删除文件 A:不同步访问时间 +:添加相应权限 -:删除相应权限 =:设定相应权限 lsattr:查看文件或目录的隐藏权限/etc/passwd /etc/shadow /etc/grouptom:/etc/passwd /etc/shadow /etc/group添加信息,新建宿主目录(修改宿主目录的归属)echo “tom:x:1001:1001::/home/tom:/bin/bash” &gt;&gt; /etc/passwd使用追加的方法去新建用户：追加passwd和shadow中的用户信息，然后复制模板目录文件；最后修改全部归属的权限。 11 Linux认证之nsswitch(名词解析）认证机制:3A认证:认证机制:authentication(资源申请者证明自己本身的一个过程)授权机制:authorization(用户是否可以访问一个服务或文件,用户访问服务或文件的能力)审计机制:audition root a.txt rw-login:user_name:passwd vi /etc/nsswitch.conf,该配置文件中规定了名称解析的地址文件顺序，其名词解析库位于lib64中 什么是nsswithch.conf(服务搜索顺序)文件nsswitch.conf(name service switch configuration,名字服务切换配置)文件位于/etc目录下,由它规定通过哪些途径以及按照什么顺序以及通过这些途径来查找特定类型的信息,还可以指定某个方法奏效或失效时系统将采取什么动作。 Nsswitch.conf中的每一行配置都指明了如何搜索信息,每行配置的格式如下: Info: method[[action]] [method[[action]]…] 其中,info指定该行所描述的信息的类型,method为用来查找该信息的方法,action是对前面的method返回状态的响应。action要放在方括号里。 nsswitch.conf的工作原理当需要提供nsswitch.conf文件所描述的信息的时候,系统将检查含有适当info字段的配置行。它按照从左向右的顺序开始执行配置行中指定的方法。在默认情况下,如果找到期望的信息,系统将停止搜索。如果没有指定action,那么当某个方法未能返回结果时,系统就会尝试下一个动作。有可能搜索结束都没有找到想要的信息。 信息(Info)Nsswitch.conf文件通常控制着用户(在passwd中)、口令(在shadow中)、主机IP和组信息(在group中)的搜索。下面的列表描述了nsswitch.conf文件控制搜索的大多数信息(Info项)的类型。 automount:自动挂载(/etc/auto.master和/etc/auto.misc)bootparams:无盘引导选项和其他引导选项(参见bootparam的手册页)ethers:MAC地址group:用户所在组(/etc/group),getgrent()函数使用该文件hosts:主机名和主机号(/etc/hosts),gethostbyname()以及类似的函数使用该文件networks:网络名及网络号(/etc/networks),getnetent()函数使用该文件passwd:用户口令(/etc/passwd),getpwent()函数使用该文件protocols:网络协议(/etc/protocols),getprotoent()函数使用该文件publickey:NIS+及NFS所使用的secure_rpc的公开密钥rpc:远程过程调用名及调用号(/etc/rpc),getrpcbyname()及类似函数使用该文件services:网络服务(/etc/services),getservent()函数使用该文件shadow:映射口令信息(/etc/shadow),getspnam()函数使用该文件aiases:邮件别名,sendmail()函数使用该文件 方法(method)下面列出了nsswich.conf文件控制搜索信息类型的方法,对于每一种信息类型,都可以指定下面的一种或多种方法:files:搜索本地文件,如/etc/passwd和/etc/hostsnis:搜索NIS数据库,nis还有一个别名,即ypdns:查询DNS(只查询主机)compat:passwd、group和shadow文件中的±语法 搜索顺序(从左至右)两个或者更多方法所提供的信息可能会重叠。举例来说,files和nis可能都提供同一个用户的口令信息。如果出现信息重叠现象,就需要考虑将哪一种方法作为权威方法(优先考虑),并将该方法放在方法列表中靠左的位置上。默认nsswitch.conf文件列出的方法并没有动作项,并假设没有信息重叠(正常情况)。在这种情况下,搜索顺序无关紧要:当一种方法失败之后,系统就会尝试下一种方法,只是时间上受到一点损失。如果在方法之间设置了动作,或者重叠的项的内容不同,那么搜索顺序就变得重要起来。例如下面两行nsswitch.conf文件配置行:passwd files nishost nis files dns第一行让系统在/etc/passwd文件中搜索口令信息,如果失败的话,就使用NIS来查找信息。如果正在查找的用户同时出现在这两个地方,就会使用本地文件中的信息,因此它就是权威信息。第二行先使用NIS搜索；如果失败的话,就搜索/etc/hosts文件；如果再次失败的话,核对DNS以找出主机信息。 动作项([action])在每个方法后面都可以选择跟一个动作项,用来指定如果由于某种原因该方法成功抑或失败需要做些什么。动作项的格式如下:[[!]STATUS =action]其中,开头和末尾的方括号属于格式的一部分,并不是用来指出括号中的内容是可选的。STATUS(按照约定使用大写字母,但本身并不区分大小写)是待测试的状态,action是如果STATUS匹配前面的方法所返回的状态将要执行的动作。开头的感叹号(!)是可选的,其作用是将状态取反。STATUS的取值如下:NOTFOUND:方法已经执行,但是并没有找到待搜索的值。 默认的动作是continue。SUCCESS:方法已经执行,并且已经找到待搜索的值,没有返回错误。默认动作是return。UNAVAIL:方法失败,原因是永久不可用。举例来说,所需的文件不可访问或者所需的服务器可能停机。默认的动作是continue。TRYAGAIN:方法失败,原因是临时不可用。举例来说,某个文件被锁定,或者某台服务器超载。默认动作是continue。action的取值如下:return:返回到调用例程,带有返回值,或者不带返回值。continue:继续执行下一个方法。任何返回值都会被下一个方法找到的值覆盖。示例:举例来说,下面这行取自nsswitch.conf文件,它的作用是让系统首先使用DNS来搜索给定主机的IP地址。DNS方法后面的动作项是测试该方法所返回的状态是否为“非(!)UNAVAIL”。hosts dns [!UNAVAIL=return] files如果DNS方法没有返回UNAVAIL(!UNAVAIL),也就是说DNS返回SUCCESS、NOTFOUND或者TRYAGAIN,那么系统就会执行与该STATUS相关的动作(return)。其结果就是,只有在DNS服务器不可用的情况下才会使用后面的方法(files)。如果DNS服务器并不是不可用(两次否定之后就是“可用”),那么搜索返回域名或者报告未找到域名。只有当服务器不可用的时候,搜索才会使用files方法(检查本地的/etc/hosts文件)。 compat方法:passwd、group和shadow文件中的”±”可以在/etc/passwd、/etc/group和/etc/shadow文件中放入一些特殊的代码,(如果在nsswitch.conf文件中指定compat方法的话)让系统将本地文件和NIS映射表中的项进行合并和修改。在这些文件中,如果在行首出现加号’＋’,就表示添加NIS信息；如果出现减号’－’,就表示删除信息。举例来说,要想使用passwd文件中的这些代码,可以在nsswitch.conf文件中指定passwd: compat。然后系统就会按照顺序搜寻passwd文件,当它遇到以+或者 开头的行时,就会添加或者删除适当的NIS项。虽然可以在passwd文件的末尾放置加号,在nsswitch.conf文件中指定passwd: compat,以搜索本地的passwd文件,然后再搜寻NIS映射表,但是更高效的一种方法是在nsswitch.conf文件中添加passwd: file nis而不修改passwd文件。 12 Linux认证之PAM12.1 PAM的Login模块login（登陆过程，先解析后验证）:①root–nsswitch.conf–passwd: files②123–nsswitch.conf–shadow: files③authentication:123–sha512(salt)–/etc/shadow compare①和②由nsswitch到passwd和shadow中去查找，第三步交由PAM来处理，直接验证nsswitch：files db nis ldapauthentication：files db nis ldap kerberos等 ldd:查看某个服务所支持的模块语法:ldd service_path，与当前目录无关 authentication：当某个应用程序需要验证的时候，会需要一个中间的模块进行辅助验证，该模块即为PAMPAM：嵌入式认证模块，PAM本身不会执行验证，需要借助一系列策略或模块来验证。12345[root@localhost security]# ldd /usr/sbin/httpd | grep libpam [root@localhost security]# cd /etc/pam.d/在这个目录下的文件包含了验证信息，如果有标识的文件找不到的话，就会到other目录中去寻找认证。[root@localhost pam.d]# cat vsftpd[root@localhost pam.d]# cat other 即：/etc/pam.d/service_name(系统中支持pam认证的服务名称)/etc/pam.d/other(当系统中支持pam认证的服务没有匹配到任何条目时,匹配other中的配置) /etc/pam.d/service_name格式，其文件内容每一列表示的内容分别为type类型 control控制标准 modules模块 [modules_args]模块的参数选项，可省略 type类型auth(entication):身份验证,匹配用户名和密码account:检查用户名和密码的有效性password:检查修改改密码时,密码是否符合标准session:检查用户会话相关属性 controlrequired:一票否决权,继续匹配下面的条目,最后不匹配(保护系统的安全性)requisite:一票否决权,不匹配下面的条目,直接给用户返回结果sufficient:一票同意权,不匹配下面的条目,直接给用户返回结果(慎用)optional:不影响最终结果include:引用其他的配置文件,把匹配权交给其他配置文件(如果其他配置跳出,则整个匹配结束)substack:引用其他的配置,把匹配权交给其他配置文件(如果其他配置跳出,则仅仅跳出子匹配) modules:匹配认证模块另外还有一种比较复杂的格式为value = action的语法来设置控制标志,标志之间会以空格分开.格式如下:value1 = action1 value2 = action2 …… 其中value可以是下列Linux PAM库的返回值:success、open_err、symbol_err、service_err、 system_err、buf_err、perm_denied、auth_err、cred_insufficient、authinfo_unavail、user_unknown、maxtries、new_authtok_reqd、acct_expired、 session_err、cred_unavail、cred_expired、cred_err、no_module_data、conv_err、 authtok_err、authtok_recover_err、authtok_lock_busy、authtok_disable_aging、 try_again、ignore、abort、authtok_expired、module_unknown、bad_item和default.最后一个(default)能够用来设置上面的返回值无法表达的行为. required [success=ok new_authtok_reqd=ok ignore=ignore default=bad]requisite [success=ok new_authtok_reqd=ok ignore=ignore default=die]sufficient [success=done new_authtok_reqd=done default=ignore]optional [success=ok new_authtok_reqd=ok default=ignore] action值ignore:忽略执行结果 bad:如果失败,结果被用于整个执行栈,后续栈继续执行 die:和bad相似,但是失败直接返回结果,后续栈不执行 ok:如果PAM_SUCCESS覆盖之前值 done:和ok 相似,但是栈直接返回结果 reset:重置栈当前状态 12.2 PAM的modules 认证模块/etc/pam.d/:每一个应用程序PAM配置文件PAM模块真正存放的位置/usr/lib64/security/:PAM认证模块文件的实际存放位置/etc/security/*:其他PAM环境的配置文件,比如 access.conf/usr/share/doc/pam-x:存放详细的PAM的说明文件 反撇号直接引用命令结果 modules:PAM认证模块/etc/pam.d/:每一个应用程序PAM配置文件/usr/lib64/security/:PAM认证模块文件的实际存放位置/etc/security/*:其他PAM环境的配置文件,比如 access.conf/usr/share/doc/pam-x:存放详细的PAM的说明文件 查看应用程序是否支持PAM认证ldd app_path如: ldd /usr/sbin/vsftpd | grep libpam pam_env.so:设置环境变量的模块,如果需要额外的环境变量,可以使用pam_env.so进行设置,配置文件/etc/security/pam_env.conf pam_unix.so:提供验证阶段的验证功能,也可以提供授权管理pam_secruetty.so:限制系统管理员只能够从安全的终端登录,安全终端:/etc/securettypam_nologin.so:限制普通使用者能否登录主机进行使用,当/etc/nologin文件存在时,所有的普通用户都无法登录pam_cracklib.so:可是限制恶意攻击,检查密码强度pam_pwquality.so:完全兼容pam_cracklib.so,检查密码强度,包括设置的密码是否在字典pam_limits.so:限制使用者打开文件数量,单个文件大小等pam_rootok.so:如果UID为0,直接通过,如root用户su到普通用户使用此模块pam_listfile.so:验证使用其他的文件pam_access.so:控制访问的模块,默认配置/etc/security/access.conf : ALL EXCEPT gooann:ALL ulimit:语法 ulimit [options] 限额options:-H:hard limit:严格的限制,必须不能超过这个设置的数值-S:soft limit:警告的限制,超过这个数值系统会发出警告,通常soft比hard小-a:后面不加任何选项,可以列出系统中所有的限制额度-c:当某个用户程序发生错误的时候,系统会将内存中的应用程序写成文件,这种文件成为核心文件(core file),限制每个核心文件的最大容量-f:此shell可以创建的文件的大小,单位kb-l:可以锁定的内存量-u:单一用户可以使用的最大的进程量-t:可以使用的最大的CPU时间 limits配置文件/etc/security/limits.conf配置文件格式 1234567891011121314151617181920domain:可以是用户,组或*,*代表所有限制type:soft(软限制) hard(硬限制)item:- core - limits the core file size (KB)- data - max data size (KB)- fsize - maximum filesize (KB)- memlock - max locked-in-memory address space (KB)- nofile - max number of open file descriptors- rss - max resident set size (KB)- stack - max stack size (KB)- cpu - max CPU time (MIN)- nproc - max number of processes- as - address space limit (KB)- maxlogins - max number of logins for this user- maxsyslogins - max number of logins on the system- priority - the priority to run user process with- locks - max number of file locks the user can hold- sigpending - max number of pending signals- msgqueue - max memory used by POSIX message queues (bytes)- nice - max nice priority allowed to raise to values: [-20, 19] value:限制的具体数值 试验:使用pam认证模块限制sshd登录用户(pam_listfile.so) 只允许root和gooann组的用户可以登录 locate find tar gzip bzip tree stat install du df uname less more date clock hwclock]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分布式版本控制系统]]></title>
    <url>%2F2017%2F07%2F11%2FGit%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[用途：多人在线协作，记录文件中的每次改动的时间和内容。Git的诞生：BitMover公司的BitKeeper为Linux的免费使用权的收回。使得Linus自己去开发了一个版本控制系统即Git。 版本控制系统类型集中式：版本库是集中存放在中央服务器的，个人每次使用时，都必须从中央调用出来，然后改完后再放回中央。缺点即需要联网。网速可能会影响协作效率。而分布式：人人都有版本库。无需联网。这样对于同一份文件，每个人自己修改完之后，就可以存储在本地当中，随时可以修改，并且如果多人协作查看修改，则相互之间互推修改版本就可看到对方修改的内容。分布式也可以有一台充当“ 中央服务器 ”的电脑。这样方便“交换”大家的修改。修改的内容会覆盖上去。可以每个人负责不同的版块，然后拼接成一个完整的文件。然后还有所谓主次之分，即所有的修改需要经过主负责审核，才能通过与覆盖。 并且分布式相较于集中式安全，就是由于人人有版本库，就不担心其中一台电脑出事后，所有数据都丢失了。 安装Git在Linux上安装Git1.输入Git查看系统是否安装git：$ git2.根据返回的信息协作，安装。（Debian或Ubuntu Linux）键入下值即可安装。1sudo apt-get install git 如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入： ./config，make，sudo make install 这几个命令安装就好了。 在Mac OS X上安装Git两种安装方法：1.安装homebrew（软件包管理器），通过它安装Git，具体方法请参考homebrew的文档：http://brew.sh/2.AppStore安装Xcode。运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”。 在Windows上安装GitWindows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，从https://git-for-windows.github.io下载（国内镜像网站https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit） 版本库Repository，又名“仓库”可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。1234$ mkdir learngit # 创建目录$ cd learngit # 进入目录learngit$ pwd #显示目录路径/Users/michael/learngit 1234567$ git init #将目录初始化为gitInitialized empty Git repository in /Users/michael/learngit/.git/$ ls # 可以查看当前列表是否已经建立版本库learngit$ ls -ah #查看隐藏目录. .bash_history .gitconfig.. .git learngit 1$ git add readme.txt #learngit目录下新建readme.txt，然后将新建的文件夹加入到缓存区stage（或index） 1234$ git commit -m &quot;wrote a readme file&quot; #将文件提交到master区间[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 123456$ git log #查看修改的详细过程commit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 15:11:49 2013 +0800 wrote a readme file 如果觉得git log命令太多可以使用下面的这个命令，这两个可以查看自己修改过的版本，然后利用commit id进行版本回退或者前进12345$ git log --pretty=oneline #省略不必要的信息3628164fb26d48395383f8f31179f24e0882e1e0 append GPLea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributedcb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file 版本回退 在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。123$ git reset --hard HEAD^ #回到上一个版本HEAD is now at ea34578 add distributed 1$ cat readme.txt #使用cat可以查看是否回退到上一个版本 再次利用git log可以查看历史版本，就会发现刚刚的版本不见了，如果又想回去回到“未来”的状态，那么：12345$ git reflog #这个命令记录了每一次命令的过程ID，查到后再用reset就可回到未来。ea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^3628164 HEAD@&#123;1&#125;: commit: append GPLea34578 HEAD@&#123;2&#125;: commit: add distributedcb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file 而采用git status 可以查看状态（该图与上图无关联）123$ git status #查看版本修改的确定态# On branch masternothing to commit (working directory clean) 为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。下面的例子可以说明对修改过程的控制：对版本库中主分支的 readme.txt 进行.第一次修改后 git add –&gt;添加到了暂存区，如果这个时候再对 readme.txt 进行二次修改 但却没有git add 到缓存区，那么进行 git commit–&gt;提交到master中 是第一次修改后的内容，第二次的修改是无效的。[x]第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit[]第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit1$ git diff HEAD -- readme.txt 使用这个命令可以查看工作区和版本库里最新版本的区别，以分辨提交的是第几次修改的内容1$ cat readme.txt #使用cat命令可以查看txt文本的内容 后悔药1.如果在工作区的文件输入错误但未添加到暂缓区域，可使用 git checkout – file 丢弃修改。[x]如果缓存区中原有该文件，则回退到缓存区的文件状态。[x]如果没有，则是回退到版本库master中的文件状态。1$ git checkout -- readme.txt 2.若错误内容已添加git add到了暂缓区域，但未 commit。可使用reset 命令回到到工作区。 git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt 3.不仅 git add –&gt;缓存区，而且还 git commit–&gt;到版本库了…还好还好，还没推到远程仓库。使用上面说过的 版本回退 就可以回到初始状态啦，不虚不虚 4.删除文件：git rm file，删错可使用于 git checkout -- 一键还原 远程仓库Github（先在Github中配置所需要的步骤SSH keygen）1.关联远程仓库。远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。例如：12$ git remote add origin git@github.com:Github账户名/learngit.gitgit remote add origin git@server-name:path/repo-name.git 2.把本地库的所有内容推送到远程库上 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。1$ git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 1$ git push origin master 分支管理Git鼓励大量使用分支：查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 解决冲突：[]本地分支冲突， 解决完冲突再提交即可。[]远程仓库，多人协作冲突。推送到远程库中出现冲突那么要使用下拉，先冲远程拉下文件，在本地解决完冲突再提交即可。但在下拉前要注意 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name再使用 git pull ，后续与本地分支冲突处理方法类似。 标签管理Tagtag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。1.给分支打标签：在分支所在目录下 运行 git tag 即可12$ git tag #再用这个即可查看所有标签名 2.给 commit Id 打标签：如果commit id是6224937，则12$ git tag v0.9 6224937 先用git tag 查看了所有标签后， 用 git show 可查看对应标签的详细信息。1234567$ git show v0.9commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Thu Aug 22 11:22:08 2013 +0800 add merge 3.标签打错了，也可以删除1234命令git push origin &lt;tagname&gt;可以推送一个本地标签；命令git push origin --tags可以推送全部未推送过的本地标签；命令git tag -d &lt;tagname&gt;可以删除一个本地标签；命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 $ git tag -d 标签 配置别名利用$ git config --global alias.别名 原命令名 ” 就可以给复杂的命令配置别名$ git config --global alias.st status后面的就不写啦啦啦，详细的教程都在廖雪峰的网站上面有。 https://www.liaoxuefeng.com/]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
